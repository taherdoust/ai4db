id,instruction,input,output_postgis,output_spatialite,complexity,usage_index,evidence_schemas,evidence_tables,evidence_functions
A1_point_in_polygon,Convert this natural language description to spatial SQL: Find all areas that contain a specific point,Find all areas that contain a specific point,"SELECT a.{id_col}, a.{attr_cols}
FROM {areas_table} a
JOIN {points_table} p
  ON ST_Intersects(p.{geom}, a.{geom})
WHERE p.{id_col} = {point_id};","SELECT a.{id_col}, a.{attr_cols}
FROM {areas_table} a
JOIN {points_table} p
  ON Intersects(p.{geom}, a.{geom})
WHERE p.{id_col} = {point_id};",A,very_high:vector,,,ST_Intersects
A2_distance_filter,Convert this natural language description to spatial SQL: Find features within a certain distance of a point,Find features within a certain distance of a point,"SELECT f.*
FROM {features} f
WHERE ST_DWithin(
  f.{geom}::geography,
  ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})::geography,
  {meters}
);","SELECT f.*
FROM {features} f
WHERE Distance(
  f.{geom},
  SetSRID(MakePoint({lon}, {lat}), {srid}),
  {meters}
);",A,very_high:vector,,,"ST_MakePoint,ST_DWithin,ST_SetSRID"
A3_knn_nearest,Convert this natural language description to spatial SQL: Find the k nearest features to a given point,Find the k nearest features to a given point,"SELECT f.*
FROM {features} f
ORDER BY f.{geom} <-> ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})
LIMIT {k};","SELECT f.*
FROM {features} f
ORDER BY f.{geom} SetSRID(MakePoint({lon}, {lat}), {srid})
LIMIT {k};",A,very_high:vector,,,"ST_MakePoint,ST_SetSRID"
A4_basic_buffer,Convert this natural language description to spatial SQL: Create a buffer around features,Create a buffer around features,"SELECT {id_col}, ST_Buffer({geom}, {buffer_distance}) AS buffered_geom
FROM {features};","SELECT {id_col}, Buffer({geom}, {buffer_distance}) AS buffered_geom
FROM {features};",A,very_high:vector,,,ST_Buffer
A5_area_calculation,Convert this natural language description to spatial SQL: Calculate area of polygon features,Calculate area of polygon features,"SELECT {id_col}, ST_Area({geom}) AS area_sqm
FROM {polygons}
ORDER BY area_sqm DESC;","SELECT {id_col}, Area({geom}) AS area_sqm
FROM {polygons}
ORDER BY area_sqm DESC;",A,very_high:vector,,,ST_Area
A6_length_calculation,Convert this natural language description to spatial SQL: Calculate length of line features,Calculate length of line features,"SELECT {id_col}, ST_Length({geom}) AS length_m
FROM {lines}
ORDER BY length_m DESC;","SELECT {id_col}, GLength({geom}) AS length_m
FROM {lines}
ORDER BY length_m DESC;",A,very_high:vector,,,ST_Length
B1_spatial_join_count,Convert this natural language description to spatial SQL: Count points within each polygon area,Count points within each polygon area,"SELECT a.{id_col}, COUNT(p.*) AS n_points
FROM {areas} a
LEFT JOIN {points} p
  ON ST_Intersects(p.{geom}, a.{geom})
GROUP BY a.{id_col};","SELECT a.{id_col}, COUNT(p.*) AS n_points
FROM {areas} a
LEFT JOIN {points} p
  ON Intersects(p.{geom}, a.{geom})
GROUP BY a.{id_col};",B,very_high:vector,,,ST_Intersects
B2_reproject_buffer_join,"Convert this natural language description to spatial SQL: Reproject lines, buffer them, and find intersecting sites","Reproject lines, buffer them, and find intersecting sites","WITH proj AS (
  SELECT id, ST_Transform({geom}, {target_srid}) AS g FROM {lines}
)
SELECT s.*
FROM {sites} s
JOIN proj l
  ON ST_DWithin(s.{geom}, ST_Buffer(l.g, {buffer_units}), 0);","WITH proj AS (
  SELECT id, Transform({geom}, {target_srid}) AS g FROM {lines}
)
SELECT s.*
FROM {sites} s
JOIN proj l
  ON Distance(s.{geom}, Buffer(l.g, {buffer_units}), 0);",B,very_high:vector,l,"l.g,proj","ST_Buffer,ST_DWithin,ST_Transform"
B3_dissolve_by_category,Convert this natural language description to spatial SQL: Merge polygons by category using union operation,Merge polygons by category using union operation,"SELECT {category}, ST_Union({geom}) AS geom
FROM {polygons}
GROUP BY {category};","SELECT {category}, ST_Union({geom}) AS geom
FROM {polygons}
GROUP BY {category};",B,high:vector,,,ST_Union
B4_makevalid_overlay,Convert this natural language description to spatial SQL: Clean invalid geometries and calculate intersection areas,Clean invalid geometries and calculate intersection areas,"WITH clean AS (
  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}
)
SELECT ST_Area(ST_Intersection(c.g, o.{geom})) AS inter_area
FROM clean c
JOIN {other} o
  ON ST_Intersects(c.g, o.{geom});","WITH clean AS (
  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}
)
SELECT Area(Intersection(c.g, o.{geom})) AS inter_area
FROM clean c
JOIN {other} o
  ON Intersects(c.g, o.{geom});",B,very_high:vector,c,"clean,c.g","ST_Intersects,ST_Area,ST_MakeValid,ST_Intersection"
B5_spatial_aggregation,Convert this natural language description to spatial SQL: Aggregate spatial features by administrative boundary,Aggregate spatial features by administrative boundary,"SELECT admin.{admin_name},
       COUNT(f.*) AS feature_count,
       AVG(ST_Area(f.{geom})) AS avg_area
FROM {features} f
JOIN {admin_boundaries} admin
  ON ST_Within(f.{geom}, admin.{geom})
GROUP BY admin.{admin_name};","SELECT admin.{admin_name},
       COUNT(f.*) AS feature_count,
       AVG(Area(f.{geom})) AS avg_area
FROM {features} f
JOIN {admin_boundaries} admin
  ON Within(f.{geom}, admin.{geom})
GROUP BY admin.{admin_name};",B,very_high:vector,,,"ST_Within,ST_Area"
B6_convex_hull_analysis,Convert this natural language description to spatial SQL: Create convex hull around grouped points,Create convex hull around grouped points,"SELECT {group_col}, 
       ST_ConvexHull(ST_Collect({geom})) AS hull_geom,
       COUNT(*) AS point_count
FROM {points}
GROUP BY {group_col};","SELECT {group_col}, 
       ConvexHull(ST_Collect({geom})) AS hull_geom,
       COUNT(*) AS point_count
FROM {points}
GROUP BY {group_col};",B,medium:vector,,,"ST_Collect,ST_ConvexHull"
C10_grid_building_proximity,Convert this natural language description to spatial SQL: Analyze electrical grid infrastructure proximity to buildings with voltage level considerations,Analyze electrical grid infrastructure proximity to buildings with voltage level considerations,"WITH building_grid_proximity AS (
  SELECT b.building_id, bp.type, bp.height, bp.area,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) AS distance_to_grid,
         RANK() OVER (PARTITION BY b.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) AS proximity_rank
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id  
  JOIN {grid_bus} gb ON gb.project_id = bp.project_id AND gb.scenario_id = bp.scenario_id
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
    AND gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, {max_distance})
),
voltage_requirements AS (
  SELECT building_id, type, height, area,
         CASE 
           WHEN type IN ('industrial', 'commercial') AND area > 1000 THEN 'high_voltage'
           WHEN type = 'residential' AND height > 20 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END AS required_voltage_level
  FROM building_grid_proximity
  WHERE proximity_rank = 1
)
SELECT bgp.building_id, bgp.type, bgp.distance_to_grid,
       bgp.voltage_kv, bgp.substation_name,
       vr.required_voltage_level,
       CASE 
         WHEN vr.required_voltage_level = 'high_voltage' AND bgp.voltage_kv >= 10 THEN 'adequate'
         WHEN vr.required_voltage_level = 'medium_voltage' AND bgp.voltage_kv >= 1 THEN 'adequate'
         WHEN vr.required_voltage_level = 'low_voltage' AND bgp.voltage_kv >= 0.4 THEN 'adequate'
         ELSE 'insufficient'
       END AS grid_adequacy
FROM building_grid_proximity bgp
JOIN voltage_requirements vr ON bgp.building_id = vr.building_id
WHERE bgp.proximity_rank = 1
ORDER BY bgp.distance_to_grid;",-- Not available in SpatiaLite,C,very_high:vector,"bp,bgp,b,gb,0,vr","b.building_id,bgp.substation_name,0.4,bgp.distance_to_grid,gb.name,bgp.proximity_rank,bp.building_id,gb.in_service,gb.bus_id,bgp.building_id,bp.area,voltage_requirements,bgp.type,building_grid_proximity,vr.required_voltage_level,bp.project_id,bp.type,b.building_geometry,gb.geometry,vr.building_id,gb.project_id,bgp.voltage_kv,bp.scenario_id,gb.scenario_id,bp.height,gb.voltage_kv","ST_DWithin,ST_Distance"
C11_multi_schema_spatial_analysis,"Convert this natural language description to spatial SQL: Comprehensive spatial analysis across vector, census, and building data with distance-based clustering","Comprehensive spatial analysis across vector, census, and building data with distance-based clustering","WITH spatial_clusters AS (
  SELECT b.building_id, bp.type, bp.n_people,
         c.SEZ2011, c.P1 as population, c.REGIONE,
         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) 
         OVER (PARTITION BY bp.type) AS cluster_id
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON ST_Within(ST_Centroid(b.building_geometry), c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
),
cluster_stats AS (
  SELECT cluster_id, type, REGIONE,
         COUNT(*) AS building_count,
         SUM(n_people) AS total_residents,
         AVG(population) AS avg_census_population,
         ST_ConvexHull(ST_Collect(ST_Centroid(b.building_geometry))) AS cluster_boundary
  FROM spatial_clusters sc
  JOIN {buildings} b ON sc.building_id = b.building_id
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, type, REGIONE
  HAVING COUNT(*) >= {min_cluster_size}
)
SELECT cluster_id, type, REGIONE, building_count, total_residents,
       ROUND(avg_census_population, 0) AS avg_census_pop,
       ST_Area(cluster_boundary) AS cluster_area_sqm,
       ROUND(total_residents::float / (ST_Area(cluster_boundary) / 10000), 2) AS density_per_hectare
FROM cluster_stats
ORDER BY density_per_hectare DESC;","WITH spatial_clusters AS (
  SELECT b.building_id, bp.type, bp.n_people,
         c.SEZ2011, c.P1 as population, c.REGIONE,
         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) 
         OVER (PARTITION BY bp.type) AS cluster_id
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON Within(Centroid(b.building_geometry), c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
),
cluster_stats AS (
  SELECT cluster_id, type, REGIONE,
         COUNT(*) AS building_count,
         SUM(n_people) AS total_residents,
         AVG(population) AS avg_census_population,
         ConvexHull(ST_Collect(Centroid(b.building_geometry))) AS cluster_boundary
  FROM spatial_clusters sc
  JOIN {buildings} b ON sc.building_id = b.building_id
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, type, REGIONE
  HAVING COUNT(*) >= {min_cluster_size}
)
SELECT cluster_id, type, REGIONE, building_count, total_residents,
       ROUND(avg_census_population, 0) AS avg_census_pop,
       Area(cluster_boundary) AS cluster_area_sqm,
       ROUND(total_residents::float / (Area(cluster_boundary) / 10000), 2) AS density_per_hectare
FROM cluster_stats
ORDER BY density_per_hectare DESC;",C,very_high:clustering,"bp,sc,b,c","b.building_id,c.SEZ2011,c.P1,cluster_stats,bp.building_id,spatial_clusters,b.building_geometry,sc.building_id,bp.scenario_id,c.geometry,c.REGIONE,bp.project_id,bp.type,bp.n_people","ST_Within,ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
C1_knn_per_group,Convert this natural language description to spatial SQL: Find k nearest neighbors for each point in a group,Find k nearest neighbors for each point in a group,"SELECT *
FROM (
  SELECT p.id AS p_id, f.id AS f_id,
         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} <-> p.{geom}) AS rk
  FROM {points} p
  JOIN {features} f ON TRUE
) x
WHERE rk <= {k};","SELECT *
FROM (
  SELECT p.id AS p_id, f.id AS f_id,
         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} p.{geom}) AS rk
  FROM {points} p
  JOIN {features} f ON TRUE
) x
WHERE rk <= {k};",C,low:vector,"f,p","p.id,f.id",
C2_linear_referencing,Convert this natural language description to spatial SQL: Project point onto line and split line at that location,Project point onto line and split line at that location,"WITH s AS (
  SELECT l.id, ST_LineLocatePoint(l.{geom}, ST_SetSRID(ST_MakePoint({lon},{lat}),{srid})) AS frac
  FROM {lines} l WHERE l.id = {line_id}
)
SELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,
       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end
FROM {lines} l
JOIN s ON s.id = l.id;","WITH s AS (
  SELECT l.id, ST_LineLocatePoint(l.{geom}, SetSRID(MakePoint({lon},{lat}),{srid})) AS frac
  FROM {lines} l WHERE l.id = {line_id}
)
SELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,
       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end
FROM {lines} l
JOIN s ON s.id = l.id;",C,very_high:vector,"s,l","l.id,s.frac,s.id","ST_LineSubstring,ST_MakePoint,ST_LineLocatePoint,ST_SetSRID"
C3_cluster_analysis,Convert this natural language description to spatial SQL: Perform DBSCAN clustering on point locations,Perform DBSCAN clustering on point locations,"SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *
FROM {points};","SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *
FROM {points};",C,low:clustering,,,ST_ClusterDBSCAN
C4_topology_analysis,Convert this natural language description to spatial SQL: Analyze topological relationships between polygon features,Analyze topological relationships between polygon features,"SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,
       CASE 
         WHEN ST_Contains(a.{geom}, b.{geom}) THEN 'contains'
         WHEN ST_Within(a.{geom}, b.{geom}) THEN 'within'
         WHEN ST_Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'
         WHEN ST_Touches(a.{geom}, b.{geom}) THEN 'touches'
         ELSE 'disjoint'
       END AS relationship
FROM {polygons} a
JOIN {polygons} b ON a.{id_col} != b.{id_col}
WHERE ST_Intersects(a.{geom}, b.{geom}) OR ST_Touches(a.{geom}, b.{geom});","SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,
       CASE 
         WHEN Contains(a.{geom}, b.{geom}) THEN 'contains'
         WHEN Within(a.{geom}, b.{geom}) THEN 'within'
         WHEN Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'
         WHEN Touches(a.{geom}, b.{geom}) THEN 'touches'
         ELSE 'disjoint'
       END AS relationship
FROM {polygons} a
JOIN {polygons} b ON a.{id_col} != b.{id_col}
WHERE Intersects(a.{geom}, b.{geom}) OR Touches(a.{geom}, b.{geom});",C,very_high:topology,,,"ST_Within,ST_Intersects,ST_Contains,ST_Overlaps,ST_Touches"
C5_network_analysis,Convert this natural language description to spatial SQL: Find connected components in a line network,Find connected components in a line network,"WITH nodes AS (
  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom
  FROM {lines}
),
connected AS (
  SELECT ST_ClusterIntersecting(node_geom) AS component
  FROM nodes
)
SELECT ROW_NUMBER() OVER () AS component_id, 
       ST_NumGeometries(component) AS node_count
FROM connected;","WITH nodes AS (
  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom
  FROM {lines}
),
connected AS (
  SELECT ST_ClusterIntersecting(node_geom) AS component
  FROM nodes
)
SELECT ROW_NUMBER() OVER () AS component_id, 
       ST_NumGeometries(component) AS node_count
FROM connected;",C,medium:network,,"connected,nodes","ST_StartPoint,ST_NumGeometries,ST_ClusterIntersecting,ST_EndPoint"
C6_raster_analysis,Convert this natural language description to spatial SQL: Extract raster values at point locations,Extract raster values at point locations,"SELECT p.id, ST_Value(r.rast, 1, p.{geom}) AS elevation
FROM {raster_table} r
JOIN {points} p
  ON ST_Intersects(r.rast, p.{geom});",-- Not available in SpatiaLite,C,very_high:raster,"p,r","p.id,r.rast","ST_Intersects,ST_Value"
C6_spatial_index_query,Convert this natural language description to spatial SQL: Efficient spatial query using spatial index,Efficient spatial query using spatial index,-- Not available in PostGIS,"SELECT f.*
FROM {features} f
WHERE f.ROWID IN (
  SELECT ROWID FROM SpatialIndex 
  WHERE f_table_name = '{features}' 
  AND search_frame = BuildMbr({xmin}, {ymin}, {xmax}, {ymax}, {srid})
);",C,low:vector,f,"SpatialIndex,f.ROWID",
C7_3d_analysis,Convert this natural language description to spatial SQL: Calculate 3D distances between points with elevation,Calculate 3D distances between points with elevation,"SELECT a.{id_col}, b.{id_col},
       ST_3DDistance(a.{geom}, b.{geom}) AS distance_3d
FROM {points_3d} a
JOIN {points_3d} b ON a.{id_col} != b.{id_col}
WHERE ST_3DDistance(a.{geom}, b.{geom}) < {max_distance};",-- Not available in SpatiaLite,C,low:3d,,,ST_3DDistance
C8_building_height_raster_analysis,Convert this natural language description to spatial SQL: Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference,Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference,"WITH building_dsm AS (
  SELECT b.building_id, b.building_geometry,
         AVG(ST_Value(dsm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dsm.rast)))) AS avg_dsm_height
  FROM {buildings} b
  JOIN {dsm_raster} dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'
  GROUP BY b.building_id, b.building_geometry
),
building_dtm AS (
  SELECT b.building_id,
         AVG(ST_Value(dtm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dtm.rast)))) AS avg_dtm_height
  FROM {buildings} b
  JOIN {dtm_raster} dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'
  GROUP BY b.building_id
)
SELECT dsm.building_id, dsm.building_geometry,
       dsm.avg_dsm_height, dtm.avg_dtm_height,
       ROUND((dsm.avg_dsm_height - dtm.avg_dtm_height), 2) AS calculated_height,
       ST_Area(dsm.building_geometry) AS building_area
FROM building_dsm dsm
JOIN building_dtm dtm ON dsm.building_id = dtm.building_id
WHERE (dsm.avg_dsm_height - dtm.avg_dtm_height) > {min_height};",-- Not available in SpatiaLite,C,very_high:raster,"dsm,dtm,b","b.building_id,dsm.avg_dsm_height,dsm.building_id,dtm.building_id,building_dtm,dtm.rast,dsm.building_geometry,dtm.avg_dtm_height,b.scenario_id,building_dsm,dsm.rast,b.project_id,b.building_geometry","ST_Intersects,ST_Area,ST_Intersection,ST_Value,ST_Centroid"
C9_census_building_correlation,Convert this natural language description to spatial SQL: Correlate building properties with census data by spatial overlay analysis,Correlate building properties with census data by spatial overlay analysis,"WITH building_census AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.ST1 as total_households,
         c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) AS overlap_ratio
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.5
),
aggregated_stats AS (
  SELECT REGIONE, PROVINCIA, bp.type,
         COUNT(*) AS building_count,
         AVG(bp.height) AS avg_building_height,
         SUM(bp.area) AS total_building_area,
         AVG(bc.total_population::float / NULLIF(bc.total_households, 0)) AS avg_people_per_household,
         PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bp.n_people) AS median_occupancy
  FROM building_census bc
  GROUP BY REGIONE, PROVINCIA, bp.type
)
SELECT * FROM aggregated_stats
WHERE building_count >= {min_buildings}
ORDER BY REGIONE, PROVINCIA, type;",-- Not available in SpatiaLite,C,very_high:vector,"bp,b,bc,0,c","b.building_id,c.SEZ2011,0.5,aggregated_stats,c.REGIONE,bc.total_households,building_census,bp.building_id,bp.area,c.COMUNE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,c.ST1,bp.n_people,c.P1,bp.scenario_id,c.geometry,bc.total_population,bp.height","ST_Intersects,ST_Area,ST_Intersection"
CIM_B1_building_stats_by_type_var_1,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_2,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)","Calculate building statistics grouped by type for a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'efficiency_max'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'efficiency_max'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_3,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: renewable_2030)","Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: renewable_2030)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'renewable_2030'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'renewable_2030'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_4,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_5,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)","Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_6,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)","Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_7,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: grid_modernization)","Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_8,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: baseline)","Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: baseline)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'baseline'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'baseline'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_9,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: milan_smart_district, Scenario: grid_modernization)","Calculate building statistics grouped by type for a project scenario (Project: milan_smart_district, Scenario: grid_modernization)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'grid_modernization'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_B1_building_stats_by_type_var_10,"Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)","Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;","SELECT bp.type as building_type,
       COUNT(*) as building_count,
       AVG(bp.height) as avg_height,
       AVG(bp.area) as avg_area,
       SUM(bp.n_people) as total_population
FROM cim_vector.building_properties bp
JOIN cim_vector.building b ON bp.building_id = b.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'zero_emission'
  AND b.building_geometry IS NOT NULL
GROUP BY bp.type
ORDER BY building_count DESC;",B,low:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,bp.area,bp.scenario_id,cim_vector.building,bp.height,bp.project_id,bp.type,bp.n_people",
CIM_CENSUS_B4_foreign_population_diversity_var_1,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: zero_emission)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: zero_emission)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_2,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: efficiency_max)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: efficiency_max)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_3,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: renewable_2030)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: renewable_2030)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_4,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: baseline)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: baseline)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_5,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_6,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_7,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: grid_modernization)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: grid_modernization)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_8,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: grid_modernization)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: grid_modernization)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_9,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: milan_smart_district, Scenario: renewable_2030)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: milan_smart_district, Scenario: renewable_2030)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B4_foreign_population_diversity_var_10,"Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: turin_innovation_zone, Scenario: efficiency_max)","Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: turin_innovation_zone, Scenario: efficiency_max)","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;","WITH foreign_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as total_population,
         c.ST1 as total_foreigners,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         c.ST13 as oceania_foreigners,
         c.ST14 as stateless_persons
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0
),
diversity_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, total_foreigners,
         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,
         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,
         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,
         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,
         CASE 
           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN
             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + 
                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)
           ELSE 0
         END as diversity_index
  FROM foreign_demographics
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
       ROUND(AVG(diversity_index), 3) as avg_diversity_index,
       ROUND(AVG(european_pct), 1) as avg_european_pct,
       ROUND(AVG(african_pct), 1) as avg_african_pct,
       ROUND(AVG(asian_pct), 1) as avg_asian_pct,
       SUM(total_foreigners) as total_foreign_population
FROM diversity_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_diversity_index DESC;",B,low:vector,"cim_census,1,c","c.SEZ2011,c.P1,c.ST10,c.ST14,1.0,diversity_indicators,c.ST12,c.COMUNE,c.ST13,c.REGIONE,cim_census.census_geo,c.ST11,c.PROVINCIA,c.ST9,c.ST1,foreign_demographics",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_1,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_2,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_3,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_4,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_5,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_6,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: florence_heritage_area, Scenario: renewable_2030)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_7,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: baseline)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: baseline)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_8,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: zero_emission)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_9,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: renewable_2030)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: renewable_2030)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_CENSUS_B1_demographic_pyramid_analysis_var_10,"Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: baseline)","Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: baseline)","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;","WITH age_groups AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0
),
demographic_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         youth_0_14, adults_15_64, elderly_65_plus, total_population,
         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,
         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden
  FROM age_groups
)
SELECT PROVINCIA, 
       COUNT(*) as census_sections,
       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,
       ROUND(AVG(aging_index), 1) as avg_aging_index,
       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,
       SUM(total_population) as total_provincial_population
FROM demographic_indicators
GROUP BY PROVINCIA
ORDER BY avg_aging_index DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.REGIONE,c.P23,c.P17,c.P29,c.P18,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,age_groups,c.P26,c.P28,c.P27,c.P14,c.P1,c.P21,demographic_indicators",
CIM_C6_multi_schema_clustering_var_1,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: efficiency_max)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: efficiency_max)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_2,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_3,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: zero_emission)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: zero_emission)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 10) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 10) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_4,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: renewable_2030)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: renewable_2030)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_5,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: baseline)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: baseline)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_6,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: baseline)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: baseline)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_7,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: efficiency_max)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: efficiency_max)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_8,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: grid_modernization)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: grid_modernization)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_9,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_C6_multi_schema_clustering_var_10,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: baseline)","Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: baseline)","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;","WITH project_buildings AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         Centroid(b.building_geometry) as building_center,
         CASE 
           WHEN bp.type = 'residential' THEN 'housing'
           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'
           ELSE 'other'
         END as functional_category
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
),
spatial_clustering AS (
  SELECT building_id, type, height, area, n_people, functional_category,
         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id
  FROM project_buildings
),
cluster_analysis AS (
  SELECT cluster_id, functional_category,
         COUNT(*) as building_count,
         ROUND(AVG(height), 1) as avg_height,
         ROUND(SUM(area), 0) as total_area,
         SUM(n_people) as total_residents,
         ROUND(AVG(area), 0) as avg_building_size
  FROM spatial_clustering
  GROUP BY cluster_id, functional_category
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, functional_category, building_count, avg_height,
       total_area, total_residents, avg_building_size,
       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,
       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building
FROM cluster_analysis
ORDER BY cluster_id, functional_category;",C,high:clustering,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,b.building_geometry,spatial_clustering,bp.area,bp.scenario_id,cim_vector.building,project_buildings,cluster_analysis,bp.height,bp.project_id,bp.type,bp.n_people","ST_ClusterKMeans,ST_Centroid"
CIM_CENSUS_A2_age_dependency_ratio_var_1,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: zero_emission)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_2,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: baseline)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: baseline)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_3,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: renewable_2030)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_4,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: baseline)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: baseline)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_5,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_6,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: baseline)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: baseline)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_7,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: zero_emission)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Firenze'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Firenze'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_8,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: grid_modernization)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_9,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: baseline)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: baseline)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_A2_age_dependency_ratio_var_10,"Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)","Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.P14 as children_under_5,
       c.P27 + c.P28 + c.P29 as elderly_65_plus,
       c.P1 as total_population,
       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 > 0
ORDER BY dependency_ratio DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.P29,c.P1,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P28,c.P27,c.P14",
CIM_CENSUS_C5_demographic_transition_analysis_var_1,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 3
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 3
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_2,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: rome_green_quarter, Scenario: renewable_2030)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: rome_green_quarter, Scenario: renewable_2030)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_3,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: bologna_energy_hub, Scenario: renewable_2030)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_4,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_5,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: baseline)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: baseline)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_6,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: grid_modernization)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: grid_modernization)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_7,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: baseline)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: baseline)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_8,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: renewable_2030)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: renewable_2030)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 3
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 3
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_9,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: zero_emission)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: zero_emission)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_CENSUS_C5_demographic_transition_analysis_var_10,"Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: turin_innovation_zone, Scenario: grid_modernization)","Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;","WITH demographic_transition AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         -- Age structure indicators
         c.P14 + c.P15 + c.P16 as youth_0_14,
         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         -- Family and social structure
         c.PF3 as single_households,
         c.PF8 as large_families,
         c.P4 as singles,
         c.P5 as married,
         -- Economic indicators
         c.P61 as employed,
         c.P62 as unemployed,
         c.P130 as housewives,
         c.P131 as students,
         -- Education
         c.P47 as university_graduates,
         c.P52 as illiterate,
         -- Foreign population
         c.ST1 as foreigners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
transition_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         -- Demographic transition indicators
         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,
         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,
         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,
         -- Social modernization indicators  
         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,
         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,
         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,
         -- Economic transition
         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,
         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,
         total_population
  FROM demographic_transition
),
transition_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         aging_ratio, youth_dependency, old_age_dependency,
         individualization_index, education_modernization, cultural_diversity,
         unemployment_rate, traditional_gender_roles,
         CASE 
           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'
           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'
           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'
           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'
           ELSE 'MID_TRANSITION'
         END as demographic_transition_stage
  FROM transition_indicators
)
SELECT demographic_transition_stage, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,
       ROUND(AVG(individualization_index), 1) as avg_individualization,
       ROUND(AVG(education_modernization), 1) as avg_education_mod,
       ROUND(AVG(cultural_diversity), 1) as avg_diversity,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,
       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles
FROM transition_classification
GROUP BY demographic_transition_stage, PROVINCIA
HAVING COUNT(*) >= 10
ORDER BY avg_aging_ratio DESC;",C,low:vector,"cim_census,1,c","c.SEZ2011,c.P24,c.P20,c.P15,c.P16,c.P22,c.P62,c.REGIONE,c.P23,c.P47,transition_indicators,c.P17,c.P29,c.P18,c.P61,c.PF3,c.P25,c.COMUNE,cim_census.census_geo,c.PROVINCIA,c.P19,1.5,c.P26,c.PF8,c.P4,1.0,c.P5,c.P52,c.P130,c.P28,c.P27,c.ST1,c.P14,c.P1,c.P21,c.P131,transition_classification,c.geometry,demographic_transition",ST_TRANSITION_ADVANCED
CIM_A1_buildings_by_type_area_var_1,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: grid_modernization)","Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'grid_modernization'
  AND bp.type = 'public'
  AND ST_Area(b.building_geometry) > 158;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'grid_modernization'
  AND bp.type = 'public'
  AND Area(b.building_geometry) > 158;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_2,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: baseline)","Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: baseline)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'baseline'
  AND bp.type = 'industrial'
  AND ST_Area(b.building_geometry) > 355;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'baseline'
  AND bp.type = 'industrial'
  AND Area(b.building_geometry) > 355;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_3,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: renewable_2030)","Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: renewable_2030)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'renewable_2030'
  AND bp.type = 'mixed_use'
  AND ST_Area(b.building_geometry) > 100;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'renewable_2030'
  AND bp.type = 'mixed_use'
  AND Area(b.building_geometry) > 100;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_4,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)","Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'industrial'
  AND ST_Area(b.building_geometry) > 500;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'industrial'
  AND Area(b.building_geometry) > 500;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_5,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)","Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'mixed_use'
  AND ST_Area(b.building_geometry) > 492;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'mixed_use'
  AND Area(b.building_geometry) > 492;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_6,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)","Find buildings of specific type with area above threshold in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'mixed_use'
  AND ST_Area(b.building_geometry) > 389;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'mixed_use'
  AND Area(b.building_geometry) > 389;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_7,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: zero_emission)","Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: zero_emission)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'zero_emission'
  AND bp.type = 'mixed_use'
  AND ST_Area(b.building_geometry) > 485;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'zero_emission'
  AND bp.type = 'mixed_use'
  AND Area(b.building_geometry) > 485;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_8,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND bp.type = 'industrial'
  AND ST_Area(b.building_geometry) > 353;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'grid_modernization'
  AND bp.type = 'industrial'
  AND Area(b.building_geometry) > 353;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_9,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)","Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'public'
  AND ST_Area(b.building_geometry) > 169;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'efficiency_max'
  AND bp.type = 'public'
  AND Area(b.building_geometry) > 169;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_A1_buildings_by_type_area_var_10,"Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: milan_smart_district, Scenario: baseline)","Find buildings of specific type with area above threshold in a project scenario (Project: milan_smart_district, Scenario: baseline)","SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'baseline'
  AND bp.type = 'commercial'
  AND ST_Area(b.building_geometry) > 75;","SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'baseline'
  AND bp.type = 'commercial'
  AND Area(b.building_geometry) > 75;",A,very_high:vector,"bp,b,cim_vector","b.building_id,bp.building_id,cim_vector.building_properties,bp.scenario_id,cim_vector.building,b.lod,bp.project_id,bp.type,b.building_geometry",ST_Area
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_1,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: renewable_2030)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: renewable_2030)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_2,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: zero_emission)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: zero_emission)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_3,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_4,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: renewable_2030)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: renewable_2030)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_5,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: turin_innovation_zone, Scenario: renewable_2030)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: turin_innovation_zone, Scenario: renewable_2030)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_6,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: bologna_energy_hub, Scenario: grid_modernization)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_7,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: efficiency_max)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: efficiency_max)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_8,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: zero_emission)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: zero_emission)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_9,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_C2_building_heritage_renovation_analysis_var_10,"Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: grid_modernization)","Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: grid_modernization)","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;","WITH building_age_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.E1 as total_buildings,
         c.E8 as pre_1919_buildings,
         c.E9 as buildings_1919_1945,
         c.E10 as buildings_1946_1960,
         c.E11 as buildings_1961_1970,
         c.E12 as buildings_1971_1980,
         c.E13 as buildings_1981_1990,
         c.E14 as buildings_1991_2000,
         c.E15 as buildings_2001_2005,
         c.E16 as post_2005_buildings,
         c.E28 as excellent_condition,
         c.E29 as good_condition,
         c.E30 as mediocre_condition,
         c.E31 as poor_condition,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0
),
age_quality_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_buildings, total_population,
         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,
         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,
         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,
         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,
         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building
  FROM building_age_analysis
  WHERE total_buildings > 0
),
renovation_priority AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,
         people_per_building,
         CASE 
           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'
           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'
           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'
           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'
           ELSE 'STANDARD_MAINTENANCE'
         END as renovation_category
  FROM age_quality_indicators
)
SELECT renovation_category,
       COUNT(*) as areas_count,
       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,
       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,
       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,
       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,
       ROUND(AVG(people_per_building), 1) as avg_occupancy_density
FROM renovation_priority
GROUP BY renovation_category
ORDER BY areas_count DESC;",C,low:vector,"cim_census,c","c.SEZ2011,c.E13,c.E10,renovation_priority,c.REGIONE,c.E30,c.E11,c.E14,building_age_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,age_quality_indicators,c.E28,c.E16,c.E12,c.E31,c.P1,c.geometry,c.E1,c.E29",
CIM_CENSUS_B5_education_employment_correlation_var_1,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: baseline)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: baseline)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_2,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: zero_emission)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: zero_emission)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_3,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: renewable_2030)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: renewable_2030)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_4,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: grid_modernization)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_5,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: zero_emission)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: zero_emission)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_6,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: baseline)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: baseline)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_7,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: rome_green_quarter, Scenario: zero_emission)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: rome_green_quarter, Scenario: zero_emission)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_8,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: renewable_2030)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_9,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: zero_emission)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: zero_emission)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B5_education_employment_correlation_var_10,"Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: renewable_2030)","Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: renewable_2030)","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;","WITH education_employment AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P46 as population_6_plus,
         c.P47 as university_graduates,
         c.P48 as high_school_graduates,
         c.P49 as middle_school,
         c.P50 as elementary_only,
         c.P52 as illiterate,
         c.P60 as labor_force,
         c.P61 as employed,
         c.P62 as unemployed,
         c.P139 as income_earners
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0
),
education_employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,
         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,
         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,
         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,
         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,
         university_graduates, employed, income_earners
  FROM education_employment
),
correlation_analysis AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         university_rate, unemployment_rate, income_earner_ratio,
         CASE 
           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'
           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'
           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'
           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'
           ELSE 'AVERAGE_PROFILE'
         END as socioeconomic_profile
  FROM education_employment_indicators
)
SELECT socioeconomic_profile,
       COUNT(*) as areas_count,
       ROUND(AVG(university_rate), 1) as avg_university_rate,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio
FROM correlation_analysis
GROUP BY socioeconomic_profile
ORDER BY avg_university_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P61,c.P49,c.P139,c.P60,c.P46,c.P50,correlation_analysis,c.P48,c.P62,c.COMUNE,education_employment,c.REGIONE,cim_census.census_geo,c.P47,education_employment_indicators,c.P52,c.PROVINCIA",
CIM_CENSUS_B2_employment_labor_analysis_var_1,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: grid_modernization)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_2,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: renewable_2030)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_3,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: zero_emission)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: zero_emission)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_4,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: efficiency_max)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: efficiency_max)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_5,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: baseline)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: baseline)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Firenze' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_6,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: efficiency_max)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: efficiency_max)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_7,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: zero_emission)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: zero_emission)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 3
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_8,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: florence_heritage_area, Scenario: efficiency_max)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: florence_heritage_area, Scenario: efficiency_max)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 5
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_9,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: baseline)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: baseline)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_B2_employment_labor_analysis_var_10,"Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: rome_green_quarter, Scenario: grid_modernization)","Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: rome_green_quarter, Scenario: grid_modernization)","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;","WITH employment_stats AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P60 as labor_force_total,
         c.P61 as employed_total,
         c.P62 as unemployed_total,
         c.P128 as not_in_labor_force,
         c.P130 as housewives,
         c.P131 as students,
         c.P139 as income_earners,
         c.P1 as total_population
  FROM cim_census.census_geo c
  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0
),
employment_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,
         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,
         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,
         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate
  FROM employment_stats
  WHERE labor_force_total > 0
)
SELECT COMUNE,
       COUNT(*) as census_areas,
       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,
       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,
       ROUND(AVG(participation_rate), 1) as avg_participation_rate,
       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate
FROM employment_indicators
GROUP BY COMUNE
HAVING COUNT(*) >= 10
ORDER BY avg_unemployment_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P61,c.P139,c.P131,employment_indicators,c.P60,employment_stats,c.P62,c.COMUNE,c.P128,c.REGIONE,cim_census.census_geo,c.PROVINCIA,c.P130",
CIM_CENSUS_A4_marital_status_analysis_var_1,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: baseline)","Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: baseline)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_2,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_3,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: grid_modernization)","Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_4,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 >= 100
ORDER BY singles_percentage DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.P1 >= 100
ORDER BY singles_percentage DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_5,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: renewable_2030)","Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_6,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: turin_innovation_zone, Scenario: grid_modernization)","Analyze marital status distribution and family dissolution rates in census areas (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 100
ORDER BY singles_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 100
ORDER BY singles_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_7,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: efficiency_max)","Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: efficiency_max)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_8,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 50;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_9,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.P1 >= 500
ORDER BY singles_percentage DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_A4_marital_status_analysis_var_10,"Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P4 as singles,
       c.P5 as married_defacto,
       c.P6 as legally_separated,
       c.P7 as widowed,
       c.P8 as divorced,
       c.P1 as total_population,
       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,
       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.P1 >= 1000
ORDER BY singles_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P6,c.P4,c.P8,c.COMUNE,c.P5,cim_census.census_geo,c.PROVINCIA,c.P7",
CIM_CENSUS_C1_spatial_diversity_clustering_var_1,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_2,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: rome_green_quarter, Scenario: renewable_2030)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: rome_green_quarter, Scenario: renewable_2030)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 3) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 3) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_3,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_4,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_5,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 3
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_6,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_7,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: grid_modernization)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: grid_modernization)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 5) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_8,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 3) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 3) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 5
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_9,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_C1_spatial_diversity_clustering_var_10,"Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: renewable_2030)","Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: renewable_2030)","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       ST_Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;","WITH census_demographics AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.ST1 as foreign_population,
         c.ST9 as european_foreigners,
         c.ST10 as african_foreigners,
         c.ST11 as american_foreigners,
         c.ST12 as asian_foreigners,
         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,
         c.E1 as total_buildings,
         c.E3 as residential_buildings,
         c.E8 + c.E9 as pre_1945_buildings,
         c.E15 + c.E16 as post_2000_buildings
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000
),
spatial_clustering AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, foreign_population, foreign_percentage,
         total_buildings, residential_buildings,
         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) 
         OVER (PARTITION BY PROVINCIA) as cluster_id
  FROM census_demographics
),
cluster_analysis AS (
  SELECT cluster_id, PROVINCIA,
         COUNT(*) as census_areas_in_cluster,
         SUM(total_population) as cluster_population,
         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,
         SUM(total_buildings) as total_buildings_cluster,
         ROUND(AVG(foreign_percentage)) as diversity_index,
         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary
  FROM spatial_clustering sc
  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, PROVINCIA
  HAVING COUNT(*) >= 10
)
SELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,
       avg_foreign_pct, total_buildings_cluster,
       Area(cluster_boundary) as cluster_area_sqm,
       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare
FROM cluster_analysis
ORDER BY population_density_per_hectare DESC;",C,very_high:clustering,"cim_census,sc,cd,c","c.SEZ2011,c.ST10,c.REGIONE,cluster_analysis,c.COMUNE,c.E15,cim_census.census_geo,c.E8,c.E9,c.PROVINCIA,c.ST9,c.E3,cd.geometry,census_demographics,c.E16,sc.SEZ2011,c.ST11,c.ST1,c.P1,cd.SEZ2011,spatial_clustering,c.ST12,c.geometry,c.E1","ST_Collect,ST_ClusterDBSCAN,ST_Area,ST_Centroid,ST_ConvexHull"
CIM_CENSUS_A5_family_composition_var_1,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)","Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_2,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)","Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_3,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_4,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_5,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)","Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_6,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)","Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_7,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)","Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_8,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: zero_emission)","Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_9,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)","Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_A5_family_composition_var_10,"Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lazio'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,
       c.PF1 as total_families,
       c.PF3 as single_person_families,
       c.PF4 as two_person_families,
       c.PF5 as three_person_families,
       c.PF6 as four_person_families,
       c.PF8 as large_families_6plus,
       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,
       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lazio'
  AND c.PF1 > 0
ORDER BY large_family_pct DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.PF8,c.PF3,c.PF6,c.PF1,c.PF5,c.PF4,c.REGIONE,cim_census.census_geo,c.PROVINCIA",
CIM_CENSUS_B3_housing_characteristics_var_1,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: renewable_2030)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: renewable_2030)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_2,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: efficiency_max)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: efficiency_max)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_3,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_4,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: grid_modernization)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: grid_modernization)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_5,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_6,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: zero_emission)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: zero_emission)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_7,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: efficiency_max)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: efficiency_max)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_8,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: efficiency_max)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: efficiency_max)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_9,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: renewable_2030)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: renewable_2030)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_CENSUS_B3_housing_characteristics_var_10,"Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: baseline)","Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: baseline)","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;","WITH housing_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.A2 as occupied_homes,
         c.A6 as empty_homes,
         c.A46 as rented_families,
         c.A47 as owned_families,
         c.A44 as total_housing_surface,
         c.PF1 as total_families,
         c.PF2 as total_family_members
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0
),
housing_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,
         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,
         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,
         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,
         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person
  FROM housing_analysis
)
SELECT PROVINCIA,
       COUNT(*) as census_sections,
       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,
       ROUND(AVG(rental_rate), 1) as avg_rental_rate,
       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,
       ROUND(AVG(avg_family_size), 1) as avg_family_size,
       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person
FROM housing_indicators
GROUP BY PROVINCIA
ORDER BY avg_vacancy_rate DESC;",B,low:vector,"cim_census,c","c.SEZ2011,c.A44,housing_analysis,housing_indicators,c.PF2,c.A47,c.PF1,c.A46,c.COMUNE,c.REGIONE,cim_census.census_geo,c.A2,c.PROVINCIA,c.A6",
CIM_A2_project_at_location_var_1,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)","Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(15.032355, 40.943579), 32633));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(15.032355, 40.943579), 32633));",A,very_high:vector,"40,ps,15,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,ps.project_boundary,15.032355,40.943579","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_2,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: bologna_energy_hub, Scenario: efficiency_max)","Find project scenarios that contain a specific geographic point (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(10.264105, 39.657922), 32632));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(10.264105, 39.657922), 32632));",A,very_high:vector,"39,ps,10,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,ps.project_boundary,10.264105,39.657922","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_3,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)","Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(8.31865, 46.95476), 32632));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(8.31865, 46.95476), 32632));",A,very_high:vector,"46,ps,8,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,8.31865,ps.project_boundary,46.95476","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_4,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: zero_emission)","Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: zero_emission)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.224634, 41.813319), 4326));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.224634, 41.813319), 4326));",A,very_high:vector,"ps,41,9,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,ps.project_boundary,9.224634,41.813319","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_5,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: grid_modernization)","Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.788497, 46.773847), 32632));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.788497, 46.773847), 32632));",A,very_high:vector,"46,ps,9,cim_vector","46.773847,cim_vector.project_scenario,9.788497,ps.project_name,ps.scenario_name,ps.project_boundary","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_6,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: rome_green_quarter, Scenario: efficiency_max)","Find project scenarios that contain a specific geographic point (Project: rome_green_quarter, Scenario: efficiency_max)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(13.775668, 41.185623), 4326));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(13.775668, 41.185623), 4326));",A,very_high:vector,"ps,41,13,cim_vector","cim_vector.project_scenario,13.775668,ps.project_name,41.185623,ps.scenario_name,ps.project_boundary","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_7,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: milan_smart_district, Scenario: efficiency_max)","Find project scenarios that contain a specific geographic point (Project: milan_smart_district, Scenario: efficiency_max)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(14.47078, 43.86584), 3857));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(14.47078, 43.86584), 3857));",A,very_high:vector,"43,ps,14,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,ps.project_boundary,43.86584,14.47078","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_8,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)","Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(16.550365, 41.225267), 32632));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(16.550365, 41.225267), 32632));",A,very_high:vector,"ps,41,16,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,16.550365,ps.project_boundary,41.225267","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_9,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)","Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(11.311511, 40.714355), 32632));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(11.311511, 40.714355), 32632));",A,very_high:vector,"11,ps,40,cim_vector","cim_vector.project_scenario,11.311511,ps.project_name,40.714355,ps.scenario_name,ps.project_boundary","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_A2_project_at_location_var_10,"Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: baseline)","Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: baseline)","SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.527282, 45.578131), 4326));","SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm
FROM cim_vector.project_scenario ps
WHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.527282, 45.578131), 4326));",A,very_high:vector,"ps,45,9,cim_vector","cim_vector.project_scenario,ps.project_name,ps.scenario_name,ps.project_boundary,45.578131,9.527282","ST_Intersects,ST_Area,ST_MakePoint,ST_SetSRID"
CIM_B3_building_census_aggregation_var_1,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: baseline)","Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: baseline)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_2,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: renewable_2030)","Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: renewable_2030)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_3,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: baseline)","Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: baseline)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_4,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)","Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_5,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: grid_modernization)","Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_6,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)","Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_7,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: turin_innovation_zone, Scenario: renewable_2030)","Aggregate building data by census municipality boundaries (Project: turin_innovation_zone, Scenario: renewable_2030)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_8,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: baseline)","Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: baseline)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_9,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: grid_modernization)","Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: grid_modernization)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_B3_building_census_aggregation_var_10,"Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: renewable_2030)","Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: renewable_2030)","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         ST_Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;","WITH building_census AS (
  SELECT b.building_id, 
         b.census_id,
         bp.n_people,
         bp.area,
         Centroid(b.building_geometry) as building_center
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'
)
SELECT cg.COMUNE as municipality,
       COUNT(bc.building_id) as buildings_count,
       SUM(bc.n_people) as total_population,
       AVG(bc.area) as avg_building_area
FROM building_census bc
JOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011
GROUP BY cg.COMUNE
ORDER BY total_population DESC;",B,high:vector,"bp,b,cg,bc,cim_vector,cim_census","b.building_id,building_census,bp.building_id,cim_vector.building_properties,bp.n_people,cg.SEZ2011,bp.area,bp.scenario_id,bc.building_id,cg.COMUNE,cim_vector.building,bc.n_people,b.census_id,bc.area,cim_census.census_geo,bp.project_id,bc.census_id,b.building_geometry",ST_Centroid
CIM_C1_building_height_validation_var_1,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: milan_smart_district, Scenario: zero_emission)","Validate building heights using raster elevation data and analyze discrepancies (Project: milan_smart_district, Scenario: zero_emission)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_2,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)","Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_3,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)","Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_4,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)","Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_5,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: turin_innovation_zone, Scenario: efficiency_max)","Validate building heights using raster elevation data and analyze discrepancies (Project: turin_innovation_zone, Scenario: efficiency_max)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_6,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)","Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_7,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: grid_modernization)","Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_8,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: baseline)","Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: baseline)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_9,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: grid_modernization)","Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: grid_modernization)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_C1_building_height_validation_var_10,"Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: zero_emission)","Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: zero_emission)","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         ST_Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;","WITH building_elevation AS (
  SELECT b.building_id,
         bp.height as declared_height,
         bhc.building_height as raster_height,
         Area(b.building_geometry) as footprint_area,
         bp.volume,
         bp.n_people
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'
),
height_analysis AS (
  SELECT building_id,
         declared_height,
         raster_height,
         ABS(declared_height - raster_height) as height_difference,
         footprint_area,
         volume,
         n_people,
         CASE 
           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'
           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'
           ELSE 'consistent'
         END as height_consistency
  FROM building_elevation
  WHERE raster_height IS NOT NULL
)
SELECT height_consistency,
       COUNT(*) as building_count,
       AVG(height_difference) as avg_height_diff,
       AVG(footprint_area) as avg_footprint_area,
       SUM(n_people) as total_population
FROM height_analysis
GROUP BY height_consistency
ORDER BY building_count DESC;",C,very_high:vector,"bp,b,bhc,cim_vector,cim_raster","b.building_id,bp.building_id,bhc.building_height,cim_vector.building_properties,bp.n_people,cim_raster.building_height_cache,bp.scenario_id,bhc.building_id,bp.project_id,building_elevation,height_analysis,cim_vector.building,bp.height,bp.volume,b.building_geometry",ST_Area
CIM_CENSUS_A1_population_by_gender_var_1,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: efficiency_max)","Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: efficiency_max)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_2,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: grid_modernization)","Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_3,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: florence_heritage_area, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: florence_heritage_area, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 25;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 100
ORDER BY c.P1 DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_4,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_5,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Toscana'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_6,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)","Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_7,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 50;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_8,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)","Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 10;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_9,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P1 >= 500
ORDER BY c.P1 DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_CENSUS_A1_population_by_gender_var_10,"Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)","Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 100;","SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
       c.P1 as total_population,
       c.P2 as male_population,
       c.P3 as female_population,
       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P1 >= 1000
ORDER BY c.P1 DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P1,c.P3,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P2,c.PROVINCIA",
CIM_B2_buildings_near_grid_var_1,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)","Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 25;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 25;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_2,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)","Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 220
ORDER BY distance_to_grid_m ASC
LIMIT 10;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'bologna_energy_hub' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 220
ORDER BY distance_to_grid_m ASC
LIMIT 10;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_3,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: efficiency_max)","Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: efficiency_max)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 20
ORDER BY distance_to_grid_m ASC
LIMIT 50;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 20
ORDER BY distance_to_grid_m ASC
LIMIT 50;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_4,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: zero_emission)","Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: zero_emission)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 10;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 10;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_5,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: baseline)","Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: baseline)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
ORDER BY distance_to_grid_m ASC
LIMIT 100;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
ORDER BY distance_to_grid_m ASC
LIMIT 100;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_6,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: milan_smart_district, Scenario: renewable_2030)","Find buildings closest to high-voltage grid infrastructure (Project: milan_smart_district, Scenario: renewable_2030)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'renewable_2030'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 10;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'milan_smart_district' 
  AND bp.scenario_id = 'renewable_2030'
  AND gb.voltage_kv >= 400
ORDER BY distance_to_grid_m ASC
LIMIT 10;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_7,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: rome_green_quarter, Scenario: zero_emission)","Find buildings closest to high-voltage grid infrastructure (Project: rome_green_quarter, Scenario: zero_emission)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 20
ORDER BY distance_to_grid_m ASC
LIMIT 10;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'rome_green_quarter' 
  AND bp.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 20
ORDER BY distance_to_grid_m ASC
LIMIT 10;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_8,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)","Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 132
ORDER BY distance_to_grid_m ASC
LIMIT 10;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 132
ORDER BY distance_to_grid_m ASC
LIMIT 10;",B,very_high:vector,"bp,gb,b,cim_vector","b.building_id,gb.geometry,gb.project_id,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_9,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: grid_modernization)","Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: grid_modernization)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 0.4
ORDER BY distance_to_grid_m ASC
LIMIT 100;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'turin_innovation_zone' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 0.4
ORDER BY distance_to_grid_m ASC
LIMIT 100;",B,very_high:vector,"bp,b,gb,cim_vector,0","b.building_id,gb.geometry,gb.project_id,0.4,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_B2_buildings_near_grid_var_10,"Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)","Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)","SELECT b.building_id, 
       bp.height,
       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 0.4
ORDER BY distance_to_grid_m ASC
LIMIT 100;","SELECT b.building_id, 
       bp.height,
       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m
FROM cim_vector.building b
JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
JOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id
WHERE bp.project_id = 'florence_heritage_area' 
  AND bp.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 0.4
ORDER BY distance_to_grid_m ASC
LIMIT 100;",B,very_high:vector,"bp,b,gb,cim_vector,0","b.building_id,gb.geometry,gb.project_id,0.4,bp.building_id,cim_vector.building_properties,cim_vector.grid_bus,bp.scenario_id,cim_vector.building,gb.scenario_id,bp.height,bp.project_id,b.building_geometry,gb.voltage_kv",ST_Distance
CIM_CENSUS_A3_education_levels_var_1,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_2,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: zero_emission)","Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: zero_emission)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_3,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_4,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: grid_modernization)","Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: grid_modernization)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P46 >= 100
ORDER BY university_rate DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Piemonte'
  AND c.P46 >= 100
ORDER BY university_rate DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_5,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_6,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: turin_innovation_zone, Scenario: baseline)","Analyze education levels and university graduation rates in census areas (Project: turin_innovation_zone, Scenario: baseline)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lombardia'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_7,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: rome_green_quarter, Scenario: zero_emission)","Analyze education levels and university graduation rates in census areas (Project: rome_green_quarter, Scenario: zero_emission)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_8,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 100;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 1000
ORDER BY university_rate DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_9,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: renewable_2030)","Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: renewable_2030)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lazio'
  AND c.P46 >= 100
ORDER BY university_rate DESC
LIMIT 25;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Lazio'
  AND c.P46 >= 100
ORDER BY university_rate DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_CENSUS_A3_education_levels_var_10,"Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: baseline)","Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: baseline)","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 10;","SELECT c.SEZ2011, c.COMUNE,
       c.P47 as university_graduates,
       c.P48 as high_school_graduates,
       c.P50 as elementary_only,
       c.P52 as illiterate,
       c.P46 as population_6_plus,
       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate
FROM cim_census.census_geo c
WHERE c.REGIONE = 'Emilia-Romagna'
  AND c.P46 >= 500
ORDER BY university_rate DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.P46,c.P50,c.P48,c.COMUNE,c.REGIONE,cim_census.census_geo,c.P47,c.P52",
CIM_C2_building_grid_proximity_analysis_var_1,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: efficiency_max)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: efficiency_max)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'efficiency_max'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'efficiency_max'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'efficiency_max'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'efficiency_max'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_2,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: grid_modernization)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'grid_modernization'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'grid_modernization'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'grid_modernization'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'grid_modernization'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_3,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: renewable_2030)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: renewable_2030)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'renewable_2030'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'renewable_2030'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'renewable_2030'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'renewable_2030'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_4,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: baseline)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: baseline)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'baseline'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'baseline'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'baseline'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'baseline'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_5,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_6,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_7,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: grid_modernization)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'grid_modernization'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'grid_modernization'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_8,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: baseline)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: baseline)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'baseline'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'baseline'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_9,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: milan_smart_district, Scenario: zero_emission)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: milan_smart_district, Scenario: zero_emission)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'milan_smart_district' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'milan_smart_district' AND gl.scenario_id = 'zero_emission'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_C2_building_grid_proximity_analysis_var_10,"Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: efficiency_max)","Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: efficiency_max)","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'efficiency_max'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'efficiency_max'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) 
          ORDER BY ST_Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;","WITH grid_network AS (
  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,
         ST_StartPoint(gl.geometry) as start_point,
         ST_EndPoint(gl.geometry) as end_point,
         gl.geometry as line_geom
  FROM cim_vector.grid_line gl
  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'efficiency_max'
),
bus_connectivity AS (
  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,
         COUNT(gn.line_id) as connected_lines
  FROM cim_vector.grid_bus gb
  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus
  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'efficiency_max'
  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry
),
building_grid_proximity AS (
  SELECT b.building_id,
         bp.type,
         bp.area,
         bp.n_people,
         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,
         (SELECT voltage_kv FROM bus_connectivity 
          WHERE Distance(bus_geom, b.building_geometry, 1000) 
          ORDER BY Distance(bus_geom, b.building_geometry) 
          LIMIT 1) as nearest_voltage_level
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  CROSS JOIN bus_connectivity bc
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry
)
SELECT type as building_type,
       nearest_voltage_level,
       COUNT(*) as building_count,
       AVG(area) as avg_area,
       SUM(n_people) as total_population,
       AVG(min_distance_to_bus) as avg_distance_to_grid
FROM building_grid_proximity
WHERE nearest_voltage_level IS NOT NULL
GROUP BY type, nearest_voltage_level
ORDER BY nearest_voltage_level DESC, building_count DESC;",C,very_high:vector,"bp,b,gb,gn,bc,cim_vector,gl","b.building_id,gn.to_bus,bc.bus_geom,gl.length_km,gl.line_id,cim_vector.grid_line,gl.geometry,bp.building_id,gl.max_loading_percent,gb.bus_id,bp.area,gl.project_id,gl.scenario_id,building_grid_proximity,bp.project_id,bp.type,b.building_geometry,gb.geometry,gl.from_bus,cim_vector.grid_bus,grid_network,gb.project_id,bp.n_people,gn.line_id,gn.from_bus,cim_vector.building_properties,bp.scenario_id,bus_connectivity,cim_vector.building,gb.scenario_id,gl.to_bus,gb.voltage_kv","ST_DWithin,ST_StartPoint,ST_Distance,ST_EndPoint"
CIM_A3_grid_buses_by_voltage_var_1,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 10
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 10
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_2,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: baseline)","Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: baseline)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_3,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: grid_modernization)","Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: grid_modernization)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'florence_heritage_area' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'florence_heritage_area' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_4,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: renewable_2030)","Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: renewable_2030)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'renewable_2030'
  AND gb.voltage_kv >= 0.4
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'renewable_2030'
  AND gb.voltage_kv >= 0.4
  AND gb.in_service = true;",A,low:vector,"gb,0,cim_vector","gb.geometry,0.4,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_5,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)","Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_6,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)","Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_7,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'rome_green_quarter' 
  AND gb.scenario_id = 'grid_modernization'
  AND gb.voltage_kv >= 400
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_8,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)","Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'bologna_energy_hub' 
  AND gb.scenario_id = 'baseline'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_9,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: milan_smart_district, Scenario: zero_emission)","Find active grid buses above certain voltage level in a project scenario (Project: milan_smart_district, Scenario: zero_emission)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'milan_smart_district' 
  AND gb.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'milan_smart_district' 
  AND gb.scenario_id = 'zero_emission'
  AND gb.voltage_kv >= 220
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_A3_grid_buses_by_voltage_var_10,"Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)","Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)","SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'florence_heritage_area' 
  AND gb.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 20
  AND gb.in_service = true;","SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location
FROM cim_vector.grid_bus gb
WHERE gb.project_id = 'florence_heritage_area' 
  AND gb.scenario_id = 'efficiency_max'
  AND gb.voltage_kv >= 20
  AND gb.in_service = true;",A,low:vector,"gb,cim_vector","gb.geometry,gb.name,gb.in_service,gb.bus_id,cim_vector.grid_bus,gb.scenario_id,gb.project_id,gb.voltage_kv",ST_AsText
CIM_CENSUS_A6_building_structure_analysis_var_1,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: renewable_2030)","Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: renewable_2030)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.E1 >= 5
ORDER BY high_rise_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.E1 >= 5
ORDER BY high_rise_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_2,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)","Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 20
ORDER BY high_rise_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 20
ORDER BY high_rise_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_3,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)","Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 100;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_4,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)","Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_5,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: zero_emission)","Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: zero_emission)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 100;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 100;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_6,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","Analyze building height distribution and interior complexity in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 25;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Torino'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 25;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_7,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: efficiency_max)","Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: efficiency_max)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Firenze'
  AND c.E1 >= 20
ORDER BY high_rise_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Firenze'
  AND c.E1 >= 20
ORDER BY high_rise_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_8,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: zero_emission)","Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: zero_emission)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 50;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Bologna'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_9,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)","Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.E1 >= 5
ORDER BY high_rise_percentage DESC
LIMIT 50;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Milano'
  AND c.E1 >= 5
ORDER BY high_rise_percentage DESC
LIMIT 50;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_CENSUS_A6_building_structure_analysis_var_10,"Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: efficiency_max)","Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: efficiency_max)","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 10;","SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,
       c.E17 as single_floor_buildings,
       c.E18 as two_floor_buildings,
       c.E19 as three_floor_buildings,
       c.E20 as four_plus_floor_buildings,
       c.E21 as single_interior_buildings,
       c.E22 as two_interior_buildings,
       c.E26 as buildings_16plus_interiors,
       c.E1 as total_buildings,
       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,
       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage
FROM cim_census.census_geo c
WHERE c.PROVINCIA = 'Roma'
  AND c.E1 >= 10
ORDER BY high_rise_percentage DESC
LIMIT 10;",A,low:vector,"cim_census,c","c.SEZ2011,c.E18,c.E21,c.E19,c.COMUNE,c.E22,cim_census.census_geo,c.E26,c.PROVINCIA,c.E1,c.E20,c.E17",
CIM_C3_3d_raster_building_analysis_var_1,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: grid_modernization)","3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: grid_modernization)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'grid_modernization'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_2,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)","3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_3,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)","3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_4,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: grid_modernization)","3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_5,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)","3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_6,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: renewable_2030)","3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: renewable_2030)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_7,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)","3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_8,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: renewable_2030)","3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: renewable_2030)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_9,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)","3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C3_3d_raster_building_analysis_var_10,"Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)","3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)","WITH building_raster_stats AS (
  SELECT b.building_id,
         bp.type,
         bp.height as declared_height,
         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,
         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,
         ST_Area(b.building_geometry) as footprint_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'
)
SELECT type,
       COUNT(*) as building_count,
       AVG(declared_height) as avg_declared_height,
       AVG(surface_elevation - ground_elevation) as avg_raster_height,
       AVG(ground_elevation) as avg_ground_elevation,
       SUM(footprint_area) as total_footprint_area,
       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy
FROM building_raster_stats
WHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL
GROUP BY type
ORDER BY avg_height_discrepancy DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,building_raster_stats,bp.scenario_id,cim_raster.dsm_raster,cim_vector.building,dsm.rast,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_Value,ST_Centroid"
CIM_C5_integrated_census_grid_analysis_var_1,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: renewable_2030)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'renewable_2030'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 500)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 20
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_2,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 500)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 10
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_3,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: milan_smart_district, Scenario: zero_emission)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: milan_smart_district, Scenario: zero_emission)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 5
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_4,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: grid_modernization)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'grid_modernization'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 5
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_5,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 500)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 20
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_6,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: efficiency_max)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: efficiency_max)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'efficiency_max'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 500)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 5
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_7,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: baseline)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: baseline)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'baseline'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 20
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_8,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: grid_modernization)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 1000)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 10
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_9,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: zero_emission)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: zero_emission)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 1000)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 20
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_C5_integrated_census_grid_analysis_var_10,"Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: baseline)","Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: baseline)","WITH building_census_overlay AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7
),
grid_proximity AS (
  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,
         bco.REGIONE, bco.PROVINCIA, bco.total_population,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,
         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank
  FROM building_census_overlay bco
  JOIN cim_vector.building b ON bco.building_id = b.building_id
  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'baseline'
  WHERE gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, 500)
),
energy_analysis AS (
  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,
         gp.REGIONE, gp.PROVINCIA, gp.total_population,
         gp.grid_distance, gp.voltage_kv, gp.substation_name,
         CASE 
           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm
           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  
           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person
           ELSE gp.area * 0.02
         END as estimated_demand_kw,
         CASE
           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'
           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END as grid_level
  FROM grid_proximity gp
  WHERE gp.proximity_rank = 1
)
SELECT REGIONE, PROVINCIA, type, grid_level,
       COUNT(*) as building_count,
       ROUND(AVG(height), 1) as avg_height,
       ROUND(SUM(area), 0) as total_area,
       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,
       ROUND(AVG(grid_distance), 0) as avg_grid_distance,
       ROUND(AVG(total_population), 0) as avg_census_population,
       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building
FROM energy_analysis
GROUP BY REGIONE, PROVINCIA, type, grid_level
HAVING COUNT(*) >= 10
ORDER BY total_demand_kw DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,1,gb,gp,bco,cim_vector,c,0,cim_census","b.building_id,c.SEZ2011,gb.name,gp.grid_distance,gb.voltage_kv,bco.n_people,c.REGIONE,gp.building_id,gp.type,gp.n_people,energy_analysis,bp.building_id,gp.voltage_kv,gb.in_service,0.02,gb.bus_id,0.03,bp.area,c.COMUNE,cim_census.census_geo,bco.PROVINCIA,0.05,gp.substation_name,building_census_overlay,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,gb.geometry,gp.total_population,1.5,bco.REGIONE,cim_vector.grid_bus,gp.area,gp.REGIONE,gb.project_id,bp.n_people,c.P1,bco.area,cim_vector.building_properties,bco.total_population,gp.PROVINCIA,gp.proximity_rank,bp.scenario_id,grid_proximity,c.geometry,gp.height,bco.type,cim_vector.building,gb.scenario_id,bp.height,bco.height,0.7,bco.building_id","ST_Intersects,ST_DWithin,ST_Area,ST_Intersection,ST_Distance"
CIM_CENSUS_C4_urban_morphology_classification_var_1,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: renewable_2030)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: renewable_2030)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_2,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_3,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: zero_emission)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: zero_emission)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_4,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: efficiency_max)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: efficiency_max)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_5,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: efficiency_max)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: efficiency_max)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_6,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 3
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_7,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: zero_emission)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: zero_emission)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_8,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_9,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: milan_smart_district, Scenario: baseline)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: milan_smart_district, Scenario: baseline)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'baseline'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C4_urban_morphology_classification_var_10,"Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: baseline)","Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: baseline)","WITH demographic_density_analysis AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,
         c.P1 as total_population,
         c.P14 + c.P15 + c.P16 as children_0_14,
         c.P27 + c.P28 + c.P29 as elderly_65_plus,
         c.PF3 as single_person_families,
         c.PF8 as large_families_6plus,
         c.A2 as occupied_homes,
         ST_Area(c.geometry) as census_area_sqm
  FROM cim_census.census_geo c
  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100
),
building_density_overlay AS (
  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
         dda.total_population, dda.children_0_14, dda.elderly_65_plus,
         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
         dda.census_area_sqm,
         COUNT(b.building_id) as buildings_in_area,
         SUM(bp.area) as total_building_footprint,
         AVG(bp.height) as avg_building_height,
         SUM(bp.n_people) as building_residents
  FROM demographic_density_analysis dda
  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)
  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'
  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,
           dda.total_population, dda.children_0_14, dda.elderly_65_plus,
           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,
           dda.census_area_sqm
),
density_indicators AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         total_population, buildings_in_area, avg_building_height,
         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,
         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,
         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,
         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,
         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,
         CASE 
           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)
           ELSE 0
         END as avg_residents_per_building
  FROM building_density_overlay
  WHERE census_area_sqm > 0
),
urban_morphology_classification AS (
  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,
         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,
         single_household_pct, avg_residents_per_building,
         CASE 
           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'
           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'
           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'
           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'
           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'
           ELSE 'MIXED_RESIDENTIAL'
         END as urban_morphology_type
  FROM density_indicators
)
SELECT urban_morphology_type, PROVINCIA,
       COUNT(*) as areas_count,
       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,
       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,
       ROUND(AVG(child_ratio), 1) as avg_child_ratio,
       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,
       ROUND(AVG(single_household_pct), 1) as avg_single_households,
       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg
FROM urban_morphology_classification
GROUP BY urban_morphology_type, PROVINCIA
HAVING COUNT(*) >= 5
ORDER BY avg_pop_density DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,dda,cim_vector,c,cim_census","c.SEZ2011,b.building_id,c.P15,dda.PROVINCIA,c.P16,dda.COMUNE,c.REGIONE,dda.geometry,c.P29,bp.building_id,c.PF3,bp.area,c.COMUNE,dda.single_person_families,cim_census.census_geo,c.PROVINCIA,dda.large_families_6plus,bp.project_id,b.building_geometry,demographic_density_analysis,building_density_overlay,c.PF8,density_indicators,urban_morphology_classification,dda.children_0_14,bp.height,dda.total_population,dda.census_area_sqm,c.P28,c.P27,bp.n_people,c.P14,c.P1,dda.occupied_homes,cim_vector.building_properties,dda.elderly_65_plus,bp.scenario_id,c.geometry,dda.SEZ2011,cim_vector.building,c.A2,dda.REGIONE","ST_Within,ST_Area,ST_Centroid"
CIM_CENSUS_C3_socioeconomic_building_integration_var_1,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: baseline)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: baseline)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'
    AND c.REGIONE = 'Lazio'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 5
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_2,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: baseline)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: baseline)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'
    AND c.REGIONE = 'Toscana'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 20
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_3,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
    AND c.REGIONE = 'Piemonte'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 5
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_4,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: efficiency_max)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: efficiency_max)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
    AND c.REGIONE = 'Toscana'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 20
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_5,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: zero_emission)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: zero_emission)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
    AND c.REGIONE = 'Toscana'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 20
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_6,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: rome_green_quarter, Scenario: efficiency_max)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: rome_green_quarter, Scenario: efficiency_max)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
    AND c.REGIONE = 'Toscana'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 20
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_7,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
    AND c.REGIONE = 'Lazio'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 5
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_8,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: milan_smart_district, Scenario: zero_emission)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: milan_smart_district, Scenario: zero_emission)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'
    AND c.REGIONE = 'Lazio'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 5
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_9,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: renewable_2030)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'
    AND c.REGIONE = 'Lazio'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 10
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_CENSUS_C3_socioeconomic_building_integration_var_10,"Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: grid_modernization)","Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: grid_modernization)","WITH census_building_overlay AS (
  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,
         c.P1 as census_population,
         c.P47 as university_graduates,
         c.P61 as employed_residents,
         c.A47 as owned_families,
         c.PF1 as total_families,
         c.E3 as residential_buildings_census,
         b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio
  FROM cim_census.census_geo c
  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'
    AND c.REGIONE = 'Lazio'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6
),
socioeconomic_building_profile AS (
  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,
         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,
         cbo.census_population, cbo.university_graduates, cbo.employed_residents,
         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,
         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,
         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,
         CASE 
           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'
           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'
           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'
           ELSE 'STANDARD_MIXED_USE'
         END as socioeconomic_profile
  FROM census_building_overlay cbo
)
SELECT socioeconomic_profile, PROVINCIA,
       COUNT(DISTINCT building_id) as buildings_count,
       COUNT(DISTINCT SEZ2011) as census_areas_count,
       ROUND(AVG(education_index), 1) as avg_education_index,
       ROUND(AVG(employment_index), 1) as avg_employment_index,
       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,
       ROUND(AVG(height), 1) as avg_building_height,
       ROUND(SUM(area), 0) as total_building_area,
       SUM(n_people) as total_building_residents
FROM socioeconomic_building_profile
GROUP BY socioeconomic_profile, PROVINCIA
HAVING COUNT(DISTINCT building_id) >= 10
ORDER BY avg_education_index DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,b,cbo,cim_vector,c,0,cim_census","c.SEZ2011,b.building_id,c.PF1,c.REGIONE,c.P47,0.6,c.P61,bp.building_id,cbo.census_population,cbo.COMUNE,cbo.PROVINCIA,bp.area,cbo.type,0.25,c.COMUNE,cbo.university_graduates,cim_census.census_geo,cbo.REGIONE,c.PROVINCIA,bp.project_id,bp.type,b.building_geometry,cbo.height,c.E3,cbo.total_families,census_building_overlay,cbo.employed_residents,c.A47,cbo.SEZ2011,cbo.area,cbo.owned_families,bp.n_people,c.P1,cbo.building_id,0.65,cim_vector.building_properties,bp.scenario_id,c.geometry,cbo.n_people,cim_vector.building,0.70,bp.height,socioeconomic_building_profile","ST_Intersects,ST_Area,ST_Intersection"
CIM_C4_precise_building_height_raster_var_1,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: renewable_2030)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: renewable_2030)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'
    AND bp.type = 'industrial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 9
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_2,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: renewable_2030)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: renewable_2030)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'
    AND bp.type = 'mixed_use'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 3
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_3,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: baseline)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: baseline)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'
    AND bp.type = 'residential'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 6
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_4,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: florence_heritage_area, Scenario: efficiency_max)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: florence_heritage_area, Scenario: efficiency_max)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'
    AND bp.type = 'commercial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 9
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_5,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: renewable_2030)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: renewable_2030)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'
    AND bp.type = 'industrial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 7
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_6,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: grid_modernization)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: grid_modernization)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'
    AND bp.type = 'mixed_use'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 8
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_7,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: efficiency_max)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: efficiency_max)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'
    AND bp.type = 'commercial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 3
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_8,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: baseline)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: baseline)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'
    AND bp.type = 'commercial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 6
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_9,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: grid_modernization)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: grid_modernization)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'
    AND bp.type = 'commercial'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 7
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"
CIM_C4_precise_building_height_raster_var_10,"Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: zero_emission)","Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: zero_emission)","WITH building_raster_intersections AS (
  SELECT b.building_id, bp.type, bp.height as declared_height,
         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,
         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,
         ST_Area(b.building_geometry) as building_area
  FROM cim_vector.building b
  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id
  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'
    AND bp.type = 'mixed_use'
),
height_calculations AS (
  SELECT building_id, type, declared_height,
         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,
         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,
         building_area,
         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,
         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count
  FROM building_raster_intersections
  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL
)
SELECT building_id, type, declared_height, building_area,
       ROUND(avg_dsm_elevation, 2) as surface_elevation,
       ROUND(avg_dtm_elevation, 2) as ground_elevation,
       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,
       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,
       dsm_pixel_count, dtm_pixel_count
FROM height_calculations
WHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL
  AND (avg_dsm_elevation - avg_dtm_elevation) > 5
ORDER BY height_difference DESC;",-- Not available in SpatiaLite (raster operations),C,very_high:vector,"bp,dtm,b,cim_vector,cim_raster,dsm","b.building_id,bp.building_id,cim_vector.building_properties,dtm.rast,bp.scenario_id,cim_raster.dsm_raster,building_raster_intersections,cim_vector.building,dsm.rast,height_calculations,bp.height,cim_raster.dtm_raster,bp.project_id,bp.type,b.building_geometry","ST_Intersects,ST_Area,ST_SummaryStats,ST_Intersection"

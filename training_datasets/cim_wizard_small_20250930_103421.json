[
  {
    "id": "A1_point_in_polygon",
    "instruction": "Convert this natural language description to spatial SQL: Find all areas that contain a specific point",
    "input": "Find all areas that contain a specific point",
    "output_postgis": "SELECT a.{id_col}, a.{attr_cols}\nFROM {areas_table} a\nJOIN {points_table} p\n  ON ST_Intersects(p.{geom}, a.{geom})\nWHERE p.{id_col} = {point_id};",
    "output_spatialite": "SELECT a.{id_col}, a.{attr_cols}\nFROM {areas_table} a\nJOIN {points_table} p\n  ON Intersects(p.{geom}, a.{geom})\nWHERE p.{id_col} = {point_id};",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Intersects"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A2_distance_filter",
    "instruction": "Convert this natural language description to spatial SQL: Find features within a certain distance of a point",
    "input": "Find features within a certain distance of a point",
    "output_postgis": "SELECT f.*\nFROM {features} f\nWHERE ST_DWithin(\n  f.{geom}::geography,\n  ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})::geography,\n  {meters}\n);",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nWHERE Distance(\n  f.{geom},\n  SetSRID(MakePoint({lon}, {lat}), {srid}),\n  {meters}\n);",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_MakePoint",
        "ST_DWithin",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A3_knn_nearest",
    "instruction": "Convert this natural language description to spatial SQL: Find the k nearest features to a given point",
    "input": "Find the k nearest features to a given point",
    "output_postgis": "SELECT f.*\nFROM {features} f\nORDER BY f.{geom} <-> ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})\nLIMIT {k};",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nORDER BY f.{geom} SetSRID(MakePoint({lon}, {lat}), {srid})\nLIMIT {k};",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A4_basic_buffer",
    "instruction": "Convert this natural language description to spatial SQL: Create a buffer around features",
    "input": "Create a buffer around features",
    "output_postgis": "SELECT {id_col}, ST_Buffer({geom}, {buffer_distance}) AS buffered_geom\nFROM {features};",
    "output_spatialite": "SELECT {id_col}, Buffer({geom}, {buffer_distance}) AS buffered_geom\nFROM {features};",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Buffer"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A5_area_calculation",
    "instruction": "Convert this natural language description to spatial SQL: Calculate area of polygon features",
    "input": "Calculate area of polygon features",
    "output_postgis": "SELECT {id_col}, ST_Area({geom}) AS area_sqm\nFROM {polygons}\nORDER BY area_sqm DESC;",
    "output_spatialite": "SELECT {id_col}, Area({geom}) AS area_sqm\nFROM {polygons}\nORDER BY area_sqm DESC;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Area"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A6_length_calculation",
    "instruction": "Convert this natural language description to spatial SQL: Calculate length of line features",
    "input": "Calculate length of line features",
    "output_postgis": "SELECT {id_col}, ST_Length({geom}) AS length_m\nFROM {lines}\nORDER BY length_m DESC;",
    "output_spatialite": "SELECT {id_col}, GLength({geom}) AS length_m\nFROM {lines}\nORDER BY length_m DESC;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Length"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B1_spatial_join_count",
    "instruction": "Convert this natural language description to spatial SQL: Count points within each polygon area",
    "input": "Count points within each polygon area",
    "output_postgis": "SELECT a.{id_col}, COUNT(p.*) AS n_points\nFROM {areas} a\nLEFT JOIN {points} p\n  ON ST_Intersects(p.{geom}, a.{geom})\nGROUP BY a.{id_col};",
    "output_spatialite": "SELECT a.{id_col}, COUNT(p.*) AS n_points\nFROM {areas} a\nLEFT JOIN {points} p\n  ON Intersects(p.{geom}, a.{geom})\nGROUP BY a.{id_col};",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Intersects"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B2_reproject_buffer_join",
    "instruction": "Convert this natural language description to spatial SQL: Reproject lines, buffer them, and find intersecting sites",
    "input": "Reproject lines, buffer them, and find intersecting sites",
    "output_postgis": "WITH proj AS (\n  SELECT id, ST_Transform({geom}, {target_srid}) AS g FROM {lines}\n)\nSELECT s.*\nFROM {sites} s\nJOIN proj l\n  ON ST_DWithin(s.{geom}, ST_Buffer(l.g, {buffer_units}), 0);",
    "output_spatialite": "WITH proj AS (\n  SELECT id, Transform({geom}, {target_srid}) AS g FROM {lines}\n)\nSELECT s.*\nFROM {sites} s\nJOIN proj l\n  ON Distance(s.{geom}, Buffer(l.g, {buffer_units}), 0);",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "l"
      ],
      "tables": [
        "l.g",
        "proj"
      ],
      "columns": [
        "g"
      ],
      "functions": [
        "ST_Buffer",
        "ST_DWithin",
        "ST_Transform"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B3_dissolve_by_category",
    "instruction": "Convert this natural language description to spatial SQL: Merge polygons by category using union operation",
    "input": "Merge polygons by category using union operation",
    "output_postgis": "SELECT {category}, ST_Union({geom}) AS geom\nFROM {polygons}\nGROUP BY {category};",
    "output_spatialite": "SELECT {category}, ST_Union({geom}) AS geom\nFROM {polygons}\nGROUP BY {category};",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Union"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B4_makevalid_overlay",
    "instruction": "Convert this natural language description to spatial SQL: Clean invalid geometries and calculate intersection areas",
    "input": "Clean invalid geometries and calculate intersection areas",
    "output_postgis": "WITH clean AS (\n  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}\n)\nSELECT ST_Area(ST_Intersection(c.g, o.{geom})) AS inter_area\nFROM clean c\nJOIN {other} o\n  ON ST_Intersects(c.g, o.{geom});",
    "output_spatialite": "WITH clean AS (\n  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}\n)\nSELECT Area(Intersection(c.g, o.{geom})) AS inter_area\nFROM clean c\nJOIN {other} o\n  ON Intersects(c.g, o.{geom});",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "c"
      ],
      "tables": [
        "clean",
        "c.g"
      ],
      "columns": [
        "g"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakeValid",
        "ST_Intersection"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B5_spatial_aggregation",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate spatial features by administrative boundary",
    "input": "Aggregate spatial features by administrative boundary",
    "output_postgis": "SELECT admin.{admin_name},\n       COUNT(f.*) AS feature_count,\n       AVG(ST_Area(f.{geom})) AS avg_area\nFROM {features} f\nJOIN {admin_boundaries} admin\n  ON ST_Within(f.{geom}, admin.{geom})\nGROUP BY admin.{admin_name};",
    "output_spatialite": "SELECT admin.{admin_name},\n       COUNT(f.*) AS feature_count,\n       AVG(Area(f.{geom})) AS avg_area\nFROM {features} f\nJOIN {admin_boundaries} admin\n  ON Within(f.{geom}, admin.{geom})\nGROUP BY admin.{admin_name};",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Within",
        "ST_Area"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B6_convex_hull_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Create convex hull around grouped points",
    "input": "Create convex hull around grouped points",
    "output_postgis": "SELECT {group_col}, \n       ST_ConvexHull(ST_Collect({geom})) AS hull_geom,\n       COUNT(*) AS point_count\nFROM {points}\nGROUP BY {group_col};",
    "output_spatialite": "SELECT {group_col}, \n       ConvexHull(ST_Collect({geom})) AS hull_geom,\n       COUNT(*) AS point_count\nFROM {points}\nGROUP BY {group_col};",
    "complexity": "B",
    "usage_index": "medium:vector",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Collect",
        "ST_ConvexHull"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C10_grid_building_proximity",
    "instruction": "Convert this natural language description to spatial SQL: Analyze electrical grid infrastructure proximity to buildings with voltage level considerations",
    "input": "Analyze electrical grid infrastructure proximity to buildings with voltage level considerations",
    "output_postgis": "WITH building_grid_proximity AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) AS distance_to_grid,\n         RANK() OVER (PARTITION BY b.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) AS proximity_rank\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id  \n  JOIN {grid_bus} gb ON gb.project_id = bp.project_id AND gb.scenario_id = bp.scenario_id\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n    AND gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, {max_distance})\n),\nvoltage_requirements AS (\n  SELECT building_id, type, height, area,\n         CASE \n           WHEN type IN ('industrial', 'commercial') AND area > 1000 THEN 'high_voltage'\n           WHEN type = 'residential' AND height > 20 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END AS required_voltage_level\n  FROM building_grid_proximity\n  WHERE proximity_rank = 1\n)\nSELECT bgp.building_id, bgp.type, bgp.distance_to_grid,\n       bgp.voltage_kv, bgp.substation_name,\n       vr.required_voltage_level,\n       CASE \n         WHEN vr.required_voltage_level = 'high_voltage' AND bgp.voltage_kv >= 10 THEN 'adequate'\n         WHEN vr.required_voltage_level = 'medium_voltage' AND bgp.voltage_kv >= 1 THEN 'adequate'\n         WHEN vr.required_voltage_level = 'low_voltage' AND bgp.voltage_kv >= 0.4 THEN 'adequate'\n         ELSE 'insufficient'\n       END AS grid_adequacy\nFROM building_grid_proximity bgp\nJOIN voltage_requirements vr ON bgp.building_id = vr.building_id\nWHERE bgp.proximity_rank = 1\nORDER BY bgp.distance_to_grid;",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "bgp",
        "b",
        "gb",
        "0",
        "vr"
      ],
      "tables": [
        "b.building_id",
        "bgp.substation_name",
        "0.4",
        "bgp.distance_to_grid",
        "gb.name",
        "bgp.proximity_rank",
        "bp.building_id",
        "gb.in_service",
        "gb.bus_id",
        "bgp.building_id",
        "bp.area",
        "voltage_requirements",
        "bgp.type",
        "building_grid_proximity",
        "vr.required_voltage_level",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "vr.building_id",
        "gb.project_id",
        "bgp.voltage_kv",
        "bp.scenario_id",
        "gb.scenario_id",
        "bp.height",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "proximity_rank",
        "4",
        "building_geometry",
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "distance_to_grid",
        "substation_name",
        "required_voltage_level",
        "height",
        "bus_id",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_Distance"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C11_multi_schema_spatial_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive spatial analysis across vector, census, and building data with distance-based clustering",
    "input": "Comprehensive spatial analysis across vector, census, and building data with distance-based clustering",
    "output_postgis": "WITH spatial_clusters AS (\n  SELECT b.building_id, bp.type, bp.n_people,\n         c.SEZ2011, c.P1 as population, c.REGIONE,\n         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) \n         OVER (PARTITION BY bp.type) AS cluster_id\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON ST_Within(ST_Centroid(b.building_geometry), c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n),\ncluster_stats AS (\n  SELECT cluster_id, type, REGIONE,\n         COUNT(*) AS building_count,\n         SUM(n_people) AS total_residents,\n         AVG(population) AS avg_census_population,\n         ST_ConvexHull(ST_Collect(ST_Centroid(b.building_geometry))) AS cluster_boundary\n  FROM spatial_clusters sc\n  JOIN {buildings} b ON sc.building_id = b.building_id\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, type, REGIONE\n  HAVING COUNT(*) >= {min_cluster_size}\n)\nSELECT cluster_id, type, REGIONE, building_count, total_residents,\n       ROUND(avg_census_population, 0) AS avg_census_pop,\n       ST_Area(cluster_boundary) AS cluster_area_sqm,\n       ROUND(total_residents::float / (ST_Area(cluster_boundary) / 10000), 2) AS density_per_hectare\nFROM cluster_stats\nORDER BY density_per_hectare DESC;",
    "output_spatialite": "WITH spatial_clusters AS (\n  SELECT b.building_id, bp.type, bp.n_people,\n         c.SEZ2011, c.P1 as population, c.REGIONE,\n         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) \n         OVER (PARTITION BY bp.type) AS cluster_id\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON Within(Centroid(b.building_geometry), c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n),\ncluster_stats AS (\n  SELECT cluster_id, type, REGIONE,\n         COUNT(*) AS building_count,\n         SUM(n_people) AS total_residents,\n         AVG(population) AS avg_census_population,\n         ConvexHull(ST_Collect(Centroid(b.building_geometry))) AS cluster_boundary\n  FROM spatial_clusters sc\n  JOIN {buildings} b ON sc.building_id = b.building_id\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, type, REGIONE\n  HAVING COUNT(*) >= {min_cluster_size}\n)\nSELECT cluster_id, type, REGIONE, building_count, total_residents,\n       ROUND(avg_census_population, 0) AS avg_census_pop,\n       Area(cluster_boundary) AS cluster_area_sqm,\n       ROUND(total_residents::float / (Area(cluster_boundary) / 10000), 2) AS density_per_hectare\nFROM cluster_stats\nORDER BY density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "sc",
        "b",
        "c"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "c.P1",
        "cluster_stats",
        "bp.building_id",
        "spatial_clusters",
        "b.building_geometry",
        "sc.building_id",
        "bp.scenario_id",
        "c.geometry",
        "c.REGIONE",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "REGIONE",
        "building_geometry",
        "geometry",
        "SEZ2011",
        "P1"
      ],
      "functions": [
        "ST_Within",
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C1_knn_per_group",
    "instruction": "Convert this natural language description to spatial SQL: Find k nearest neighbors for each point in a group",
    "input": "Find k nearest neighbors for each point in a group",
    "output_postgis": "SELECT *\nFROM (\n  SELECT p.id AS p_id, f.id AS f_id,\n         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} <-> p.{geom}) AS rk\n  FROM {points} p\n  JOIN {features} f ON TRUE\n) x\nWHERE rk <= {k};",
    "output_spatialite": "SELECT *\nFROM (\n  SELECT p.id AS p_id, f.id AS f_id,\n         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} p.{geom}) AS rk\n  FROM {points} p\n  JOIN {features} f ON TRUE\n) x\nWHERE rk <= {k};",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "f",
        "p"
      ],
      "tables": [
        "p.id",
        "f.id"
      ],
      "columns": [
        "id"
      ],
      "functions": [],
      "template_source": "general"
    }
  },
  {
    "id": "C2_linear_referencing",
    "instruction": "Convert this natural language description to spatial SQL: Project point onto line and split line at that location",
    "input": "Project point onto line and split line at that location",
    "output_postgis": "WITH s AS (\n  SELECT l.id, ST_LineLocatePoint(l.{geom}, ST_SetSRID(ST_MakePoint({lon},{lat}),{srid})) AS frac\n  FROM {lines} l WHERE l.id = {line_id}\n)\nSELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,\n       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end\nFROM {lines} l\nJOIN s ON s.id = l.id;",
    "output_spatialite": "WITH s AS (\n  SELECT l.id, ST_LineLocatePoint(l.{geom}, SetSRID(MakePoint({lon},{lat}),{srid})) AS frac\n  FROM {lines} l WHERE l.id = {line_id}\n)\nSELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,\n       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end\nFROM {lines} l\nJOIN s ON s.id = l.id;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "s",
        "l"
      ],
      "tables": [
        "l.id",
        "s.frac",
        "s.id"
      ],
      "columns": [
        "frac",
        "id"
      ],
      "functions": [
        "ST_LineSubstring",
        "ST_MakePoint",
        "ST_LineLocatePoint",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C3_cluster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Perform DBSCAN clustering on point locations",
    "input": "Perform DBSCAN clustering on point locations",
    "output_postgis": "SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *\nFROM {points};",
    "output_spatialite": "SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *\nFROM {points};",
    "complexity": "C",
    "usage_index": "low:clustering",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_ClusterDBSCAN"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C4_topology_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Analyze topological relationships between polygon features",
    "input": "Analyze topological relationships between polygon features",
    "output_postgis": "SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,\n       CASE \n         WHEN ST_Contains(a.{geom}, b.{geom}) THEN 'contains'\n         WHEN ST_Within(a.{geom}, b.{geom}) THEN 'within'\n         WHEN ST_Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'\n         WHEN ST_Touches(a.{geom}, b.{geom}) THEN 'touches'\n         ELSE 'disjoint'\n       END AS relationship\nFROM {polygons} a\nJOIN {polygons} b ON a.{id_col} != b.{id_col}\nWHERE ST_Intersects(a.{geom}, b.{geom}) OR ST_Touches(a.{geom}, b.{geom});",
    "output_spatialite": "SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,\n       CASE \n         WHEN Contains(a.{geom}, b.{geom}) THEN 'contains'\n         WHEN Within(a.{geom}, b.{geom}) THEN 'within'\n         WHEN Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'\n         WHEN Touches(a.{geom}, b.{geom}) THEN 'touches'\n         ELSE 'disjoint'\n       END AS relationship\nFROM {polygons} a\nJOIN {polygons} b ON a.{id_col} != b.{id_col}\nWHERE Intersects(a.{geom}, b.{geom}) OR Touches(a.{geom}, b.{geom});",
    "complexity": "C",
    "usage_index": "very_high:topology",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Within",
        "ST_Intersects",
        "ST_Contains",
        "ST_Overlaps",
        "ST_Touches"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C5_network_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Find connected components in a line network",
    "input": "Find connected components in a line network",
    "output_postgis": "WITH nodes AS (\n  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom\n  FROM {lines}\n),\nconnected AS (\n  SELECT ST_ClusterIntersecting(node_geom) AS component\n  FROM nodes\n)\nSELECT ROW_NUMBER() OVER () AS component_id, \n       ST_NumGeometries(component) AS node_count\nFROM connected;",
    "output_spatialite": "WITH nodes AS (\n  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom\n  FROM {lines}\n),\nconnected AS (\n  SELECT ST_ClusterIntersecting(node_geom) AS component\n  FROM nodes\n)\nSELECT ROW_NUMBER() OVER () AS component_id, \n       ST_NumGeometries(component) AS node_count\nFROM connected;",
    "complexity": "C",
    "usage_index": "medium:network",
    "evidence": {
      "schemas": [],
      "tables": [
        "connected",
        "nodes"
      ],
      "columns": [],
      "functions": [
        "ST_StartPoint",
        "ST_NumGeometries",
        "ST_ClusterIntersecting",
        "ST_EndPoint"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C6_raster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Extract raster values at point locations",
    "input": "Extract raster values at point locations",
    "output_postgis": "SELECT p.id, ST_Value(r.rast, 1, p.{geom}) AS elevation\nFROM {raster_table} r\nJOIN {points} p\n  ON ST_Intersects(r.rast, p.{geom});",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "very_high:raster",
    "evidence": {
      "schemas": [
        "p",
        "r"
      ],
      "tables": [
        "p.id",
        "r.rast"
      ],
      "columns": [
        "rast",
        "id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Value"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C6_spatial_index_query",
    "instruction": "Convert this natural language description to spatial SQL: Efficient spatial query using spatial index",
    "input": "Efficient spatial query using spatial index",
    "output_postgis": "-- Not available in PostGIS",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nWHERE f.ROWID IN (\n  SELECT ROWID FROM SpatialIndex \n  WHERE f_table_name = '{features}' \n  AND search_frame = BuildMbr({xmin}, {ymin}, {xmax}, {ymax}, {srid})\n);",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "f"
      ],
      "tables": [
        "SpatialIndex",
        "f.ROWID"
      ],
      "columns": [
        "ROWID"
      ],
      "functions": [],
      "template_source": "general"
    }
  },
  {
    "id": "C7_3d_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Calculate 3D distances between points with elevation",
    "input": "Calculate 3D distances between points with elevation",
    "output_postgis": "SELECT a.{id_col}, b.{id_col},\n       ST_3DDistance(a.{geom}, b.{geom}) AS distance_3d\nFROM {points_3d} a\nJOIN {points_3d} b ON a.{id_col} != b.{id_col}\nWHERE ST_3DDistance(a.{geom}, b.{geom}) < {max_distance};",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "low:3d",
    "evidence": {
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_3DDistance"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C8_building_height_raster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference",
    "input": "Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference",
    "output_postgis": "WITH building_dsm AS (\n  SELECT b.building_id, b.building_geometry,\n         AVG(ST_Value(dsm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dsm.rast)))) AS avg_dsm_height\n  FROM {buildings} b\n  JOIN {dsm_raster} dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'\n  GROUP BY b.building_id, b.building_geometry\n),\nbuilding_dtm AS (\n  SELECT b.building_id,\n         AVG(ST_Value(dtm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dtm.rast)))) AS avg_dtm_height\n  FROM {buildings} b\n  JOIN {dtm_raster} dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'\n  GROUP BY b.building_id\n)\nSELECT dsm.building_id, dsm.building_geometry,\n       dsm.avg_dsm_height, dtm.avg_dtm_height,\n       ROUND((dsm.avg_dsm_height - dtm.avg_dtm_height), 2) AS calculated_height,\n       ST_Area(dsm.building_geometry) AS building_area\nFROM building_dsm dsm\nJOIN building_dtm dtm ON dsm.building_id = dtm.building_id\nWHERE (dsm.avg_dsm_height - dtm.avg_dtm_height) > {min_height};",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "very_high:raster",
    "evidence": {
      "schemas": [
        "dsm",
        "dtm",
        "b"
      ],
      "tables": [
        "b.building_id",
        "dsm.avg_dsm_height",
        "dsm.building_id",
        "dtm.building_id",
        "building_dtm",
        "dtm.rast",
        "dsm.building_geometry",
        "dtm.avg_dtm_height",
        "b.scenario_id",
        "building_dsm",
        "dsm.rast",
        "b.project_id",
        "b.building_geometry"
      ],
      "columns": [
        "building_geometry",
        "avg_dtm_height",
        "rast",
        "avg_dsm_height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C9_census_building_correlation",
    "instruction": "Convert this natural language description to spatial SQL: Correlate building properties with census data by spatial overlay analysis",
    "input": "Correlate building properties with census data by spatial overlay analysis",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.ST1 as total_households,\n         c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) AS overlap_ratio\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.5\n),\naggregated_stats AS (\n  SELECT REGIONE, PROVINCIA, bp.type,\n         COUNT(*) AS building_count,\n         AVG(bp.height) AS avg_building_height,\n         SUM(bp.area) AS total_building_area,\n         AVG(bc.total_population::float / NULLIF(bc.total_households, 0)) AS avg_people_per_household,\n         PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bp.n_people) AS median_occupancy\n  FROM building_census bc\n  GROUP BY REGIONE, PROVINCIA, bp.type\n)\nSELECT * FROM aggregated_stats\nWHERE building_count >= {min_buildings}\nORDER BY REGIONE, PROVINCIA, type;",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bc",
        "0",
        "c"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "0.5",
        "aggregated_stats",
        "c.REGIONE",
        "bc.total_households",
        "building_census",
        "bp.building_id",
        "bp.area",
        "c.COMUNE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "c.ST1",
        "bp.n_people",
        "c.P1",
        "bp.scenario_id",
        "c.geometry",
        "bc.total_population",
        "bp.height"
      ],
      "columns": [
        "type",
        "n_people",
        "ST1",
        "total_population",
        "REGIONE",
        "building_geometry",
        "total_households",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "P1",
        "height",
        "area",
        "5"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'efficiency_max'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'efficiency_max'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'renewable_2030'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'renewable_2030'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'baseline'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'baseline'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'grid_modernization'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B1_building_stats_by_type_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Calculate building statistics grouped by type for a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "output_spatialite": "SELECT bp.type as building_type,\n       COUNT(*) as building_count,\n       AVG(bp.height) as avg_height,\n       AVG(bp.area) as avg_area,\n       SUM(bp.n_people) as total_population\nFROM cim_vector.building_properties bp\nJOIN cim_vector.building b ON bp.building_id = b.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'zero_emission'\n  AND b.building_geometry IS NOT NULL\nGROUP BY bp.type\nORDER BY building_count DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B4_foreign_population_diversity_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Comprehensive analysis of foreign population diversity with continental origin distribution and diversity indices (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "output_spatialite": "WITH foreign_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as total_population,\n         c.ST1 as total_foreigners,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         c.ST13 as oceania_foreigners,\n         c.ST14 as stateless_persons\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.ST1 > 0\n),\ndiversity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, total_foreigners,\n         ROUND((total_foreigners::float / NULLIF(total_population, 0)) * 100, 1) as foreign_percentage,\n         ROUND((european_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as european_pct,\n         ROUND((african_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as african_pct,\n         ROUND((asian_foreigners::float / NULLIF(total_foreigners, 0)) * 100, 1) as asian_pct,\n         CASE \n           WHEN european_foreigners + african_foreigners + american_foreigners + asian_foreigners > 0 THEN\n             ROUND(1.0 - (POWER(european_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(african_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(american_foreigners::float / NULLIF(total_foreigners, 0), 2) + \n                         POWER(asian_foreigners::float / NULLIF(total_foreigners, 0), 2)), 3)\n           ELSE 0\n         END as diversity_index\n  FROM foreign_demographics\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n       ROUND(AVG(diversity_index), 3) as avg_diversity_index,\n       ROUND(AVG(european_pct), 1) as avg_european_pct,\n       ROUND(AVG(african_pct), 1) as avg_african_pct,\n       ROUND(AVG(asian_pct), 1) as avg_asian_pct,\n       SUM(total_foreigners) as total_foreign_population\nFROM diversity_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_diversity_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.ST10",
        "c.ST14",
        "1.0",
        "diversity_indicators",
        "c.ST12",
        "c.COMUNE",
        "c.ST13",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.ST11",
        "c.PROVINCIA",
        "c.ST9",
        "c.ST1",
        "foreign_demographics"
      ],
      "columns": [
        "ST13",
        "ST1",
        "REGIONE",
        "ST11",
        "census_geo",
        "0",
        "PROVINCIA",
        "ST14",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "P1",
        "ST10",
        "ST9"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B1_demographic_pyramid_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Analyze demographic pyramid and aging patterns across provinces with dependency burden calculations (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "output_spatialite": "WITH age_groups AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as adults_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 > 0\n),\ndemographic_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         youth_0_14, adults_15_64, elderly_65_plus, total_population,\n         ROUND((youth_0_14::float / NULLIF(total_population, 0)) * 100, 1) as youth_percentage,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as aging_index,\n         ROUND(((youth_0_14 + elderly_65_plus)::float / NULLIF(adults_15_64, 0)) * 100, 1) as dependency_burden\n  FROM age_groups\n)\nSELECT PROVINCIA, \n       COUNT(*) as census_sections,\n       ROUND(AVG(youth_percentage), 1) as avg_youth_pct,\n       ROUND(AVG(aging_index), 1) as avg_aging_index,\n       ROUND(AVG(dependency_burden), 1) as avg_dependency_burden,\n       SUM(total_population) as total_provincial_population\nFROM demographic_indicators\nGROUP BY PROVINCIA\nORDER BY avg_aging_index DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.REGIONE",
        "c.P23",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "age_groups",
        "c.P26",
        "c.P28",
        "c.P27",
        "c.P14",
        "c.P1",
        "c.P21",
        "demographic_indicators"
      ],
      "columns": [
        "P21",
        "P20",
        "P23",
        "P22",
        "P1",
        "P24",
        "P14",
        "REGIONE",
        "P25",
        "P26",
        "P29",
        "P16",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P15",
        "COMUNE",
        "P18",
        "P17"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 10) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 10) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 3) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 5) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C6_multi_schema_clustering_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis across building properties with functional categorization and demographic insights (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "output_spatialite": "WITH project_buildings AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         Centroid(b.building_geometry) as building_center,\n         CASE \n           WHEN bp.type = 'residential' THEN 'housing'\n           WHEN bp.type IN ('commercial', 'industrial') THEN 'economic'\n           ELSE 'other'\n         END as functional_category\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n),\nspatial_clustering AS (\n  SELECT building_id, type, height, area, n_people, functional_category,\n         ST_ClusterKMeans(building_center, 8) OVER () as cluster_id\n  FROM project_buildings\n),\ncluster_analysis AS (\n  SELECT cluster_id, functional_category,\n         COUNT(*) as building_count,\n         ROUND(AVG(height), 1) as avg_height,\n         ROUND(SUM(area), 0) as total_area,\n         SUM(n_people) as total_residents,\n         ROUND(AVG(area), 0) as avg_building_size\n  FROM spatial_clustering\n  GROUP BY cluster_id, functional_category\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, functional_category, building_count, avg_height,\n       total_area, total_residents, avg_building_size,\n       ROUND(total_residents::float / NULLIF(building_count, 0), 1) as people_per_building,\n       ROUND(total_area::float / NULLIF(building_count, 0), 0) as area_per_building\nFROM cluster_analysis\nORDER BY cluster_id, functional_category;",
    "complexity": "C",
    "usage_index": "high:clustering",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "b.building_geometry",
        "spatial_clustering",
        "bp.area",
        "bp.scenario_id",
        "cim_vector.building",
        "project_buildings",
        "cluster_analysis",
        "bp.height",
        "bp.project_id",
        "bp.type",
        "bp.n_people"
      ],
      "columns": [
        "type",
        "n_people",
        "building_properties",
        "building_geometry",
        "building",
        "height",
        "area"
      ],
      "functions": [
        "ST_ClusterKMeans",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: baseline)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Firenze'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Firenze'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A2_age_dependency_ratio_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Calculate age dependency ratio (children under 5 + elderly 65+) for census areas in a province (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.P14 as children_under_5,\n       c.P27 + c.P28 + c.P29 as elderly_65_plus,\n       c.P1 as total_population,\n       ROUND(((c.P14 + c.P27 + c.P28 + c.P29)::float / NULLIF(c.P1, 0)) * 100, 1) as dependency_ratio\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 > 0\nORDER BY dependency_ratio DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P29",
        "c.P1",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P28",
        "c.P27",
        "c.P14"
      ],
      "columns": [
        "P14",
        "REGIONE",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P29",
        "P1"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 3\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 3\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: baseline)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 3\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 3\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 500\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C5_demographic_transition_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Comprehensive demographic transition analysis combining aging, modernization, and social change indicators (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "output_spatialite": "WITH demographic_transition AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         -- Age structure indicators\n         c.P14 + c.P15 + c.P16 as youth_0_14,\n         c.P17 + c.P18 + c.P19 + c.P20 + c.P21 + c.P22 + c.P23 + c.P24 + c.P25 + c.P26 as working_age_15_64,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         -- Family and social structure\n         c.PF3 as single_households,\n         c.PF8 as large_families,\n         c.P4 as singles,\n         c.P5 as married,\n         -- Economic indicators\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P130 as housewives,\n         c.P131 as students,\n         -- Education\n         c.P47 as university_graduates,\n         c.P52 as illiterate,\n         -- Foreign population\n         c.ST1 as foreigners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\ntransition_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         -- Demographic transition indicators\n         ROUND((elderly_65_plus::float / NULLIF(youth_0_14, 0)), 2) as aging_ratio,\n         ROUND((youth_0_14::float / NULLIF(working_age_15_64, 0)) * 100, 1) as youth_dependency,\n         ROUND((elderly_65_plus::float / NULLIF(working_age_15_64, 0)) * 100, 1) as old_age_dependency,\n         -- Social modernization indicators  \n         ROUND((single_households::float / NULLIF(total_population, 0)) * 100, 1) as individualization_index,\n         ROUND((university_graduates::float / NULLIF(total_population, 0)) * 100, 1) as education_modernization,\n         ROUND((foreigners::float / NULLIF(total_population, 0)) * 100, 1) as cultural_diversity,\n         -- Economic transition\n         ROUND((unemployed::float / NULLIF(employed + unemployed, 0)) * 100, 1) as unemployment_rate,\n         ROUND((housewives::float / NULLIF(total_population, 0)) * 100, 1) as traditional_gender_roles,\n         total_population\n  FROM demographic_transition\n),\ntransition_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         aging_ratio, youth_dependency, old_age_dependency,\n         individualization_index, education_modernization, cultural_diversity,\n         unemployment_rate, traditional_gender_roles,\n         CASE \n           WHEN aging_ratio > 1.5 AND individualization_index > 15 AND education_modernization > 10 THEN 'POST_TRANSITION_ADVANCED'\n           WHEN aging_ratio > 1.0 AND education_modernization > 5 THEN 'LATE_TRANSITION'\n           WHEN youth_dependency > 25 AND traditional_gender_roles > 10 THEN 'PRE_TRANSITION_TRADITIONAL'\n           WHEN unemployment_rate > 15 AND cultural_diversity > 5 THEN 'TRANSITION_WITH_CHALLENGES'\n           ELSE 'MID_TRANSITION'\n         END as demographic_transition_stage\n  FROM transition_indicators\n)\nSELECT demographic_transition_stage, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(aging_ratio), 2) as avg_aging_ratio,\n       ROUND(AVG(individualization_index), 1) as avg_individualization,\n       ROUND(AVG(education_modernization), 1) as avg_education_mod,\n       ROUND(AVG(cultural_diversity), 1) as avg_diversity,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment,\n       ROUND(AVG(traditional_gender_roles), 1) as avg_traditional_roles\nFROM transition_classification\nGROUP BY demographic_transition_stage, PROVINCIA\nHAVING COUNT(*) >= 10\nORDER BY avg_aging_ratio DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "1",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P24",
        "c.P20",
        "c.P15",
        "c.P16",
        "c.P22",
        "c.P62",
        "c.REGIONE",
        "c.P23",
        "c.P47",
        "transition_indicators",
        "c.P17",
        "c.P29",
        "c.P18",
        "c.P61",
        "c.PF3",
        "c.P25",
        "c.COMUNE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P19",
        "1.5",
        "c.P26",
        "c.PF8",
        "c.P4",
        "1.0",
        "c.P5",
        "c.P52",
        "c.P130",
        "c.P28",
        "c.P27",
        "c.ST1",
        "c.P14",
        "c.P1",
        "c.P21",
        "c.P131",
        "transition_classification",
        "c.geometry",
        "demographic_transition"
      ],
      "columns": [
        "P21",
        "P61",
        "PF3",
        "P20",
        "P23",
        "geometry",
        "P22",
        "P62",
        "P1",
        "P24",
        "P14",
        "PF8",
        "P5",
        "ST1",
        "REGIONE",
        "P25",
        "P26",
        "P131",
        "P4",
        "P29",
        "0",
        "P16",
        "5",
        "P19",
        "P27",
        "census_geo",
        "PROVINCIA",
        "P28",
        "SEZ2011",
        "P52",
        "P130",
        "P15",
        "COMUNE",
        "P18",
        "P47",
        "P17"
      ],
      "functions": [
        "ST_TRANSITION_ADVANCED"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'grid_modernization'\n  AND bp.type = 'public'\n  AND ST_Area(b.building_geometry) > 158;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'grid_modernization'\n  AND bp.type = 'public'\n  AND Area(b.building_geometry) > 158;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'baseline'\n  AND bp.type = 'industrial'\n  AND ST_Area(b.building_geometry) > 355;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'baseline'\n  AND bp.type = 'industrial'\n  AND Area(b.building_geometry) > 355;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'renewable_2030'\n  AND bp.type = 'mixed_use'\n  AND ST_Area(b.building_geometry) > 100;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'renewable_2030'\n  AND bp.type = 'mixed_use'\n  AND Area(b.building_geometry) > 100;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'industrial'\n  AND ST_Area(b.building_geometry) > 500;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'industrial'\n  AND Area(b.building_geometry) > 500;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'mixed_use'\n  AND ST_Area(b.building_geometry) > 492;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'mixed_use'\n  AND Area(b.building_geometry) > 492;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'mixed_use'\n  AND ST_Area(b.building_geometry) > 389;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'mixed_use'\n  AND Area(b.building_geometry) > 389;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'zero_emission'\n  AND bp.type = 'mixed_use'\n  AND ST_Area(b.building_geometry) > 485;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'zero_emission'\n  AND bp.type = 'mixed_use'\n  AND Area(b.building_geometry) > 485;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND bp.type = 'industrial'\n  AND ST_Area(b.building_geometry) > 353;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'grid_modernization'\n  AND bp.type = 'industrial'\n  AND Area(b.building_geometry) > 353;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'public'\n  AND ST_Area(b.building_geometry) > 169;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'efficiency_max'\n  AND bp.type = 'public'\n  AND Area(b.building_geometry) > 169;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A1_buildings_by_type_area_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings of specific type with area above threshold in a project scenario (Project: milan_smart_district, Scenario: baseline)",
    "input": "Find buildings of specific type with area above threshold in a project scenario (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "SELECT b.building_id, b.lod, ST_Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'baseline'\n  AND bp.type = 'commercial'\n  AND ST_Area(b.building_geometry) > 75;",
    "output_spatialite": "SELECT b.building_id, b.lod, Area(b.building_geometry) as area_sqm\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'baseline'\n  AND bp.type = 'commercial'\n  AND Area(b.building_geometry) > 75;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "cim_vector.building",
        "b.lod",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "building_properties",
        "lod",
        "building_geometry",
        "building"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Roma' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C2_building_heritage_renovation_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Comprehensive building age and condition analysis for heritage preservation and renovation priority assessment (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "output_spatialite": "WITH building_age_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.E1 as total_buildings,\n         c.E8 as pre_1919_buildings,\n         c.E9 as buildings_1919_1945,\n         c.E10 as buildings_1946_1960,\n         c.E11 as buildings_1961_1970,\n         c.E12 as buildings_1971_1980,\n         c.E13 as buildings_1981_1990,\n         c.E14 as buildings_1991_2000,\n         c.E15 as buildings_2001_2005,\n         c.E16 as post_2005_buildings,\n         c.E28 as excellent_condition,\n         c.E29 as good_condition,\n         c.E30 as mediocre_condition,\n         c.E31 as poor_condition,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.E1 > 0\n),\nage_quality_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_buildings, total_population,\n         ROUND(((pre_1919_buildings + buildings_1919_1945)::float / NULLIF(total_buildings, 0)) * 100, 1) as historical_building_pct,\n         ROUND(((buildings_2001_2005 + post_2005_buildings)::float / NULLIF(total_buildings, 0)) * 100, 1) as modern_building_pct,\n         ROUND(((excellent_condition + good_condition)::float / NULLIF(total_buildings, 0)) * 100, 1) as good_quality_pct,\n         ROUND((poor_condition::float / NULLIF(total_buildings, 0)) * 100, 1) as deteriorated_pct,\n         ROUND((total_population::float / NULLIF(total_buildings, 0)), 1) as people_per_building\n  FROM building_age_analysis\n  WHERE total_buildings > 0\n),\nrenovation_priority AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         historical_building_pct, modern_building_pct, good_quality_pct, deteriorated_pct,\n         people_per_building,\n         CASE \n           WHEN deteriorated_pct > 20 AND historical_building_pct > 30 THEN 'URGENT_HERITAGE_RENOVATION'\n           WHEN deteriorated_pct > 15 THEN 'HIGH_PRIORITY_RENOVATION'\n           WHEN good_quality_pct > 80 AND modern_building_pct > 50 THEN 'WELL_MAINTAINED_MODERN'\n           WHEN historical_building_pct > 50 THEN 'HERITAGE_PRESERVATION'\n           ELSE 'STANDARD_MAINTENANCE'\n         END as renovation_category\n  FROM age_quality_indicators\n)\nSELECT renovation_category,\n       COUNT(*) as areas_count,\n       ROUND(AVG(historical_building_pct), 1) as avg_historical_pct,\n       ROUND(AVG(modern_building_pct), 1) as avg_modern_pct,\n       ROUND(AVG(good_quality_pct), 1) as avg_quality_pct,\n       ROUND(AVG(deteriorated_pct), 1) as avg_deterioration_pct,\n       ROUND(AVG(people_per_building), 1) as avg_occupancy_density\nFROM renovation_priority\nGROUP BY renovation_category\nORDER BY areas_count DESC;",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E13",
        "c.E10",
        "renovation_priority",
        "c.REGIONE",
        "c.E30",
        "c.E11",
        "c.E14",
        "building_age_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "age_quality_indicators",
        "c.E28",
        "c.E16",
        "c.E12",
        "c.E31",
        "c.P1",
        "c.geometry",
        "c.E1",
        "c.E29"
      ],
      "columns": [
        "geometry",
        "E29",
        "P1",
        "E15",
        "E30",
        "E8",
        "E9",
        "REGIONE",
        "E12",
        "E28",
        "E14",
        "E11",
        "E13",
        "E10",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "E31",
        "COMUNE",
        "E1",
        "E16"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: baseline)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B5_education_employment_correlation_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Correlation analysis between education levels and employment outcomes for socioeconomic profiling (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "output_spatialite": "WITH education_employment AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P46 as population_6_plus,\n         c.P47 as university_graduates,\n         c.P48 as high_school_graduates,\n         c.P49 as middle_school,\n         c.P50 as elementary_only,\n         c.P52 as illiterate,\n         c.P60 as labor_force,\n         c.P61 as employed,\n         c.P62 as unemployed,\n         c.P139 as income_earners\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P46 > 0 AND c.P60 > 0\n),\neducation_employment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((university_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as university_rate,\n         ROUND((high_school_graduates::float / NULLIF(population_6_plus, 0)) * 100, 1) as high_school_rate,\n         ROUND((illiterate::float / NULLIF(population_6_plus, 0)) * 100, 1) as illiteracy_rate,\n         ROUND((unemployed::float / NULLIF(labor_force, 0)) * 100, 1) as unemployment_rate,\n         ROUND((income_earners::float / NULLIF(employed, 0)) * 100, 1) as income_earner_ratio,\n         university_graduates, employed, income_earners\n  FROM education_employment\n),\ncorrelation_analysis AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         university_rate, unemployment_rate, income_earner_ratio,\n         CASE \n           WHEN university_rate > 20 AND unemployment_rate < 5 THEN 'HIGH_EDUCATION_LOW_UNEMPLOYMENT'\n           WHEN university_rate > 15 AND income_earner_ratio > 90 THEN 'EDUCATED_HIGH_INCOME'\n           WHEN university_rate < 5 AND unemployment_rate > 15 THEN 'LOW_EDUCATION_HIGH_UNEMPLOYMENT'\n           WHEN unemployment_rate > 20 THEN 'ECONOMIC_DISTRESS'\n           ELSE 'AVERAGE_PROFILE'\n         END as socioeconomic_profile\n  FROM education_employment_indicators\n)\nSELECT socioeconomic_profile,\n       COUNT(*) as areas_count,\n       ROUND(AVG(university_rate), 1) as avg_university_rate,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(income_earner_ratio), 1) as avg_income_ratio\nFROM correlation_analysis\nGROUP BY socioeconomic_profile\nORDER BY avg_university_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P61",
        "c.P49",
        "c.P139",
        "c.P60",
        "c.P46",
        "c.P50",
        "correlation_analysis",
        "c.P48",
        "c.P62",
        "c.COMUNE",
        "education_employment",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "education_employment_indicators",
        "c.P52",
        "c.PROVINCIA"
      ],
      "columns": [
        "P49",
        "P50",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P62",
        "P46",
        "P139",
        "P48",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Firenze' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: efficiency_max)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: efficiency_max)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Torino' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 3\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 5\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Bologna' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B2_employment_labor_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Comprehensive employment and labor force analysis with unemployment rates and participation indicators (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "output_spatialite": "WITH employment_stats AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P60 as labor_force_total,\n         c.P61 as employed_total,\n         c.P62 as unemployed_total,\n         c.P128 as not_in_labor_force,\n         c.P130 as housewives,\n         c.P131 as students,\n         c.P139 as income_earners,\n         c.P1 as total_population\n  FROM cim_census.census_geo c\n  WHERE c.PROVINCIA = 'Milano' AND c.P60 > 0\n),\nemployment_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((unemployed_total::float / NULLIF(labor_force_total, 0)) * 100, 1) as unemployment_rate,\n         ROUND((employed_total::float / NULLIF(total_population, 0)) * 100, 1) as employment_ratio,\n         ROUND((labor_force_total::float / NULLIF(total_population, 0)) * 100, 1) as participation_rate,\n         ROUND((income_earners::float / NULLIF(total_population, 0)) * 100, 1) as income_earner_rate\n  FROM employment_stats\n  WHERE labor_force_total > 0\n)\nSELECT COMUNE,\n       COUNT(*) as census_areas,\n       ROUND(AVG(unemployment_rate), 1) as avg_unemployment_rate,\n       ROUND(AVG(employment_ratio), 1) as avg_employment_ratio,\n       ROUND(AVG(participation_rate), 1) as avg_participation_rate,\n       ROUND(AVG(income_earner_rate), 1) as avg_income_earner_rate\nFROM employment_indicators\nGROUP BY COMUNE\nHAVING COUNT(*) >= 10\nORDER BY avg_unemployment_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P61",
        "c.P139",
        "c.P131",
        "employment_indicators",
        "c.P60",
        "employment_stats",
        "c.P62",
        "c.COMUNE",
        "c.P128",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P130"
      ],
      "columns": [
        "P139",
        "P130",
        "P61",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "P131",
        "COMUNE",
        "SEZ2011",
        "P62",
        "P128",
        "P1",
        "P60"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 >= 100\nORDER BY singles_percentage DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.P1 >= 100\nORDER BY singles_percentage DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 100\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 100\nORDER BY singles_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.P1 >= 500\nORDER BY singles_percentage DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A4_marital_status_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze marital status distribution and family dissolution rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P4 as singles,\n       c.P5 as married_defacto,\n       c.P6 as legally_separated,\n       c.P7 as widowed,\n       c.P8 as divorced,\n       c.P1 as total_population,\n       ROUND((c.P4::float / NULLIF(c.P1, 0)) * 100, 1) as singles_percentage,\n       ROUND(((c.P6 + c.P8)::float / NULLIF(c.P1, 0)) * 100, 1) as dissolved_marriages_pct\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.P1 >= 1000\nORDER BY singles_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P6",
        "c.P4",
        "c.P8",
        "c.COMUNE",
        "c.P5",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "c.P7"
      ],
      "columns": [
        "P5",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P4",
        "P1",
        "P7",
        "P8",
        "P6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 3) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 3) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 5000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 5000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 3\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 5) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 3) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 3) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 5\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lazio' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C1_spatial_diversity_clustering_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Advanced spatial clustering analysis of demographic diversity and foreign population distribution patterns (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(ST_Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ST_ConvexHull(ST_Collect(ST_Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       ST_Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (ST_Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "output_spatialite": "WITH census_demographics AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.ST1 as foreign_population,\n         c.ST9 as european_foreigners,\n         c.ST10 as african_foreigners,\n         c.ST11 as american_foreigners,\n         c.ST12 as asian_foreigners,\n         ROUND((c.ST1::float / NULLIF(c.P1, 0)) * 100, 1) as foreign_percentage,\n         c.E1 as total_buildings,\n         c.E3 as residential_buildings,\n         c.E8 + c.E9 as pre_1945_buildings,\n         c.E15 + c.E16 as post_2000_buildings\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 1000\n),\nspatial_clustering AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, foreign_population, foreign_percentage,\n         total_buildings, residential_buildings,\n         ST_ClusterDBSCAN(Centroid(geometry), eps := 1000, minpoints := 8) \n         OVER (PARTITION BY PROVINCIA) as cluster_id\n  FROM census_demographics\n),\ncluster_analysis AS (\n  SELECT cluster_id, PROVINCIA,\n         COUNT(*) as census_areas_in_cluster,\n         SUM(total_population) as cluster_population,\n         ROUND(AVG(foreign_percentage), 1) as avg_foreign_pct,\n         SUM(total_buildings) as total_buildings_cluster,\n         ROUND(AVG(foreign_percentage)) as diversity_index,\n         ConvexHull(ST_Collect(Centroid(cd.geometry))) as cluster_boundary\n  FROM spatial_clustering sc\n  JOIN census_demographics cd ON sc.SEZ2011 = cd.SEZ2011\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, PROVINCIA\n  HAVING COUNT(*) >= 10\n)\nSELECT cluster_id, PROVINCIA, census_areas_in_cluster, cluster_population,\n       avg_foreign_pct, total_buildings_cluster,\n       Area(cluster_boundary) as cluster_area_sqm,\n       ROUND((cluster_population::float / (Area(cluster_boundary) / 10000)), 1) as population_density_per_hectare\nFROM cluster_analysis\nORDER BY population_density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "very_high:clustering",
    "evidence": {
      "schemas": [
        "cim_census",
        "sc",
        "cd",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.ST10",
        "c.REGIONE",
        "cluster_analysis",
        "c.COMUNE",
        "c.E15",
        "cim_census.census_geo",
        "c.E8",
        "c.E9",
        "c.PROVINCIA",
        "c.ST9",
        "c.E3",
        "cd.geometry",
        "census_demographics",
        "c.E16",
        "sc.SEZ2011",
        "c.ST11",
        "c.ST1",
        "c.P1",
        "cd.SEZ2011",
        "spatial_clustering",
        "c.ST12",
        "c.geometry",
        "c.E1"
      ],
      "columns": [
        "E16",
        "E8",
        "E3",
        "ST1",
        "E9",
        "REGIONE",
        "ST11",
        "census_geo",
        "PROVINCIA",
        "geometry",
        "COMUNE",
        "SEZ2011",
        "ST12",
        "E1",
        "P1",
        "E15",
        "ST10",
        "ST9"
      ],
      "functions": [
        "ST_Collect",
        "ST_ClusterDBSCAN",
        "ST_Area",
        "ST_Centroid",
        "ST_ConvexHull"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze family size composition from single households to large families (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Analyze family size composition from single households to large families (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Analyze family size composition from single households to large families (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A5_family_composition_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze family size composition from single households to large families (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lazio'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA,\n       c.PF1 as total_families,\n       c.PF3 as single_person_families,\n       c.PF4 as two_person_families,\n       c.PF5 as three_person_families,\n       c.PF6 as four_person_families,\n       c.PF8 as large_families_6plus,\n       ROUND((c.PF3::float / NULLIF(c.PF1, 0)) * 100, 1) as single_household_pct,\n       ROUND((c.PF8::float / NULLIF(c.PF1, 0)) * 100, 1) as large_family_pct\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lazio'\n  AND c.PF1 > 0\nORDER BY large_family_pct DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.PF8",
        "c.PF3",
        "c.PF6",
        "c.PF1",
        "c.PF5",
        "c.PF4",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.PROVINCIA"
      ],
      "columns": [
        "PF8",
        "PF4",
        "REGIONE",
        "PF3",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "PF5",
        "PF6"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_B3_housing_characteristics_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: baseline)",
    "input": "Analyze housing characteristics including vacancy rates, rental patterns, and living space per person (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "output_spatialite": "WITH housing_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.A2 as occupied_homes,\n         c.A6 as empty_homes,\n         c.A46 as rented_families,\n         c.A47 as owned_families,\n         c.A44 as total_housing_surface,\n         c.PF1 as total_families,\n         c.PF2 as total_family_members\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.A2 > 0 AND c.PF1 > 0\n),\nhousing_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         ROUND((empty_homes::float / NULLIF((occupied_homes + empty_homes), 0)) * 100, 1) as vacancy_rate,\n         ROUND((rented_families::float / NULLIF(total_families, 0)) * 100, 1) as rental_rate,\n         ROUND((total_housing_surface::float / NULLIF(occupied_homes, 0)), 1) as avg_home_size_sqm,\n         ROUND((total_family_members::float / NULLIF(total_families, 0)), 1) as avg_family_size,\n         ROUND((total_housing_surface::float / NULLIF(total_family_members, 0)), 1) as sqm_per_person\n  FROM housing_analysis\n)\nSELECT PROVINCIA,\n       COUNT(*) as census_sections,\n       ROUND(AVG(vacancy_rate), 1) as avg_vacancy_rate,\n       ROUND(AVG(rental_rate), 1) as avg_rental_rate,\n       ROUND(AVG(avg_home_size_sqm), 0) as avg_home_size,\n       ROUND(AVG(avg_family_size), 1) as avg_family_size,\n       ROUND(AVG(sqm_per_person), 1) as avg_sqm_per_person\nFROM housing_indicators\nGROUP BY PROVINCIA\nORDER BY avg_vacancy_rate DESC;",
    "complexity": "B",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.A44",
        "housing_analysis",
        "housing_indicators",
        "c.PF2",
        "c.A47",
        "c.PF1",
        "c.A46",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.A2",
        "c.PROVINCIA",
        "c.A6"
      ],
      "columns": [
        "REGIONE",
        "census_geo",
        "A46",
        "PROVINCIA",
        "A44",
        "COMUNE",
        "SEZ2011",
        "A6",
        "PF1",
        "A47",
        "PF2",
        "A2"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(15.032355, 40.943579), 32633));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(15.032355, 40.943579), 32633));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "40",
        "ps",
        "15",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary",
        "15.032355",
        "40.943579"
      ],
      "columns": [
        "032355",
        "scenario_name",
        "project_name",
        "project_scenario",
        "943579",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Find project scenarios that contain a specific geographic point (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(10.264105, 39.657922), 32632));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(10.264105, 39.657922), 32632));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "39",
        "ps",
        "10",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary",
        "10.264105",
        "39.657922"
      ],
      "columns": [
        "264105",
        "scenario_name",
        "project_name",
        "project_scenario",
        "657922",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(8.31865, 46.95476), 32632));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(8.31865, 46.95476), 32632));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "46",
        "ps",
        "8",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "8.31865",
        "ps.project_boundary",
        "46.95476"
      ],
      "columns": [
        "scenario_name",
        "95476",
        "project_name",
        "project_scenario",
        "31865",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.224634, 41.813319), 4326));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.224634, 41.813319), 4326));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "ps",
        "41",
        "9",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary",
        "9.224634",
        "41.813319"
      ],
      "columns": [
        "813319",
        "scenario_name",
        "224634",
        "project_name",
        "project_scenario",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.788497, 46.773847), 32632));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.788497, 46.773847), 32632));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "46",
        "ps",
        "9",
        "cim_vector"
      ],
      "tables": [
        "46.773847",
        "cim_vector.project_scenario",
        "9.788497",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary"
      ],
      "columns": [
        "788497",
        "scenario_name",
        "project_name",
        "773847",
        "project_scenario",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Find project scenarios that contain a specific geographic point (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(13.775668, 41.185623), 4326));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(13.775668, 41.185623), 4326));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "ps",
        "41",
        "13",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "13.775668",
        "ps.project_name",
        "41.185623",
        "ps.scenario_name",
        "ps.project_boundary"
      ],
      "columns": [
        "185623",
        "scenario_name",
        "775668",
        "project_name",
        "project_scenario",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: milan_smart_district, Scenario: efficiency_max)",
    "input": "Find project scenarios that contain a specific geographic point (Project: milan_smart_district, Scenario: efficiency_max)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(14.47078, 43.86584), 3857));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(14.47078, 43.86584), 3857));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "43",
        "ps",
        "14",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary",
        "43.86584",
        "14.47078"
      ],
      "columns": [
        "scenario_name",
        "47078",
        "project_name",
        "86584",
        "project_scenario",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Find project scenarios that contain a specific geographic point (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(16.550365, 41.225267), 32632));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(16.550365, 41.225267), 32632));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "ps",
        "41",
        "16",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "16.550365",
        "ps.project_boundary",
        "41.225267"
      ],
      "columns": [
        "550365",
        "scenario_name",
        "225267",
        "project_name",
        "project_scenario",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(11.311511, 40.714355), 32632));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(11.311511, 40.714355), 32632));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "11",
        "ps",
        "40",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "11.311511",
        "ps.project_name",
        "40.714355",
        "ps.scenario_name",
        "ps.project_boundary"
      ],
      "columns": [
        "311511",
        "scenario_name",
        "project_name",
        "project_scenario",
        "714355",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A2_project_at_location_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Find project scenarios that contain a specific geographic point (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT ps.project_name, ps.scenario_name, ST_Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE ST_Intersects(ps.project_boundary, ST_SetSRID(ST_MakePoint(9.527282, 45.578131), 4326));",
    "output_spatialite": "SELECT ps.project_name, ps.scenario_name, Area(ps.project_boundary) as project_area_sqm\nFROM cim_vector.project_scenario ps\nWHERE Intersects(ps.project_boundary, SetSRID(MakePoint(9.527282, 45.578131), 4326));",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "ps",
        "45",
        "9",
        "cim_vector"
      ],
      "tables": [
        "cim_vector.project_scenario",
        "ps.project_name",
        "ps.scenario_name",
        "ps.project_boundary",
        "45.578131",
        "9.527282"
      ],
      "columns": [
        "578131",
        "scenario_name",
        "project_name",
        "project_scenario",
        "527282",
        "project_boundary"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)",
    "input": "Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Aggregate building data by census municipality boundaries (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)",
    "input": "Aggregate building data by census municipality boundaries (Project: milan_smart_district, Scenario: efficiency_max)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Aggregate building data by census municipality boundaries (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Aggregate building data by census municipality boundaries (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B3_building_census_aggregation_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Aggregate building data by census municipality boundaries (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         ST_Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "output_spatialite": "WITH building_census AS (\n  SELECT b.building_id, \n         b.census_id,\n         bp.n_people,\n         bp.area,\n         Centroid(b.building_geometry) as building_center\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT cg.COMUNE as municipality,\n       COUNT(bc.building_id) as buildings_count,\n       SUM(bc.n_people) as total_population,\n       AVG(bc.area) as avg_building_area\nFROM building_census bc\nJOIN cim_census.census_geo cg ON bc.census_id = cg.SEZ2011\nGROUP BY cg.COMUNE\nORDER BY total_population DESC;",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cg",
        "bc",
        "cim_vector",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "building_census",
        "bp.building_id",
        "cim_vector.building_properties",
        "bp.n_people",
        "cg.SEZ2011",
        "bp.area",
        "bp.scenario_id",
        "bc.building_id",
        "cg.COMUNE",
        "cim_vector.building",
        "bc.n_people",
        "b.census_id",
        "bc.area",
        "cim_census.census_geo",
        "bp.project_id",
        "bc.census_id",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_properties",
        "census_id",
        "building_geometry",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "building",
        "area"
      ],
      "functions": [
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C1_building_height_validation_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Validate building heights using raster elevation data and analyze discrepancies (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         ST_Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "output_spatialite": "WITH building_elevation AS (\n  SELECT b.building_id,\n         bp.height as declared_height,\n         bhc.building_height as raster_height,\n         Area(b.building_geometry) as footprint_area,\n         bp.volume,\n         bp.n_people\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.building_height_cache bhc ON b.building_id = bhc.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'\n),\nheight_analysis AS (\n  SELECT building_id,\n         declared_height,\n         raster_height,\n         ABS(declared_height - raster_height) as height_difference,\n         footprint_area,\n         volume,\n         n_people,\n         CASE \n           WHEN ABS(declared_height - raster_height) > 5 THEN 'significant_difference'\n           WHEN ABS(declared_height - raster_height) > 2 THEN 'moderate_difference'\n           ELSE 'consistent'\n         END as height_consistency\n  FROM building_elevation\n  WHERE raster_height IS NOT NULL\n)\nSELECT height_consistency,\n       COUNT(*) as building_count,\n       AVG(height_difference) as avg_height_diff,\n       AVG(footprint_area) as avg_footprint_area,\n       SUM(n_people) as total_population\nFROM height_analysis\nGROUP BY height_consistency\nORDER BY building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "bhc",
        "cim_vector",
        "cim_raster"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "bhc.building_height",
        "cim_vector.building_properties",
        "bp.n_people",
        "cim_raster.building_height_cache",
        "bp.scenario_id",
        "bhc.building_id",
        "bp.project_id",
        "building_elevation",
        "height_analysis",
        "cim_vector.building",
        "bp.height",
        "bp.volume",
        "b.building_geometry"
      ],
      "columns": [
        "n_people",
        "building_height",
        "building_properties",
        "building_geometry",
        "building_height_cache",
        "volume",
        "building",
        "height"
      ],
      "functions": [
        "ST_Area"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 100\nORDER BY c.P1 DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Toscana'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P1 >= 500\nORDER BY c.P1 DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A1_population_by_gender_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Analyze population distribution by gender in census areas for a specific region (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n       c.P1 as total_population,\n       c.P2 as male_population,\n       c.P3 as female_population,\n       ROUND((c.P2::float / NULLIF(c.P1, 0)) * 100, 1) as male_percentage\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P1 >= 1000\nORDER BY c.P1 DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P1",
        "c.P3",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P2",
        "c.PROVINCIA"
      ],
      "columns": [
        "P2",
        "REGIONE",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "P1",
        "P3"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 25;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 25;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 220\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'bologna_energy_hub' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 220\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 20\nORDER BY distance_to_grid_m ASC\nLIMIT 50;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 20\nORDER BY distance_to_grid_m ASC\nLIMIT 50;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'renewable_2030'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'milan_smart_district' \n  AND bp.scenario_id = 'renewable_2030'\n  AND gb.voltage_kv >= 400\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 20\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'rome_green_quarter' \n  AND bp.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 20\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 132\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 132\nORDER BY distance_to_grid_m ASC\nLIMIT 10;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "gb",
        "b",
        "cim_vector"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 0.4\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'turin_innovation_zone' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 0.4\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "cim_vector",
        "0"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "0.4",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "4",
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_B2_buildings_near_grid_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Find buildings closest to high-voltage grid infrastructure (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "SELECT b.building_id, \n       bp.height,\n       ST_Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 0.4\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "output_spatialite": "SELECT b.building_id, \n       bp.height,\n       Distance(b.building_geometry, gb.geometry) as distance_to_grid_m\nFROM cim_vector.building b\nJOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\nJOIN cim_vector.grid_bus gb ON bp.project_id = gb.project_id AND bp.scenario_id = gb.scenario_id\nWHERE bp.project_id = 'florence_heritage_area' \n  AND bp.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 0.4\nORDER BY distance_to_grid_m ASC\nLIMIT 100;",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "cim_vector",
        "0"
      ],
      "tables": [
        "b.building_id",
        "gb.geometry",
        "gb.project_id",
        "0.4",
        "bp.building_id",
        "cim_vector.building_properties",
        "cim_vector.grid_bus",
        "bp.scenario_id",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bp.project_id",
        "b.building_geometry",
        "gb.voltage_kv"
      ],
      "columns": [
        "4",
        "building_properties",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "building",
        "height",
        "grid_bus"
      ],
      "functions": [
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P46 >= 100\nORDER BY university_rate DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Piemonte'\n  AND c.P46 >= 100\nORDER BY university_rate DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lombardia'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: rome_green_quarter, Scenario: zero_emission)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: rome_green_quarter, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 1000\nORDER BY university_rate DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lazio'\n  AND c.P46 >= 100\nORDER BY university_rate DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Lazio'\n  AND c.P46 >= 100\nORDER BY university_rate DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A3_education_levels_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: baseline)",
    "input": "Analyze education levels and university graduation rates in census areas (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.COMUNE,\n       c.P47 as university_graduates,\n       c.P48 as high_school_graduates,\n       c.P50 as elementary_only,\n       c.P52 as illiterate,\n       c.P46 as population_6_plus,\n       ROUND((c.P47::float / NULLIF(c.P46, 0)) * 100, 1) as university_rate\nFROM cim_census.census_geo c\nWHERE c.REGIONE = 'Emilia-Romagna'\n  AND c.P46 >= 500\nORDER BY university_rate DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.P46",
        "c.P50",
        "c.P48",
        "c.COMUNE",
        "c.REGIONE",
        "cim_census.census_geo",
        "c.P47",
        "c.P52"
      ],
      "columns": [
        "P50",
        "REGIONE",
        "census_geo",
        "COMUNE",
        "SEZ2011",
        "P52",
        "P47",
        "P46",
        "P48"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: efficiency_max)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'efficiency_max'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'efficiency_max'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'efficiency_max'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'efficiency_max'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'grid_modernization'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'grid_modernization'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'grid_modernization'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'grid_modernization'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'renewable_2030'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'renewable_2030'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'renewable_2030'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'renewable_2030'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'baseline'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'baseline'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'baseline'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'baseline'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'turin_innovation_zone' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'grid_modernization'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'grid_modernization'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'baseline'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'bologna_energy_hub' AND gl.scenario_id = 'baseline'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'milan_smart_district' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'milan_smart_district' AND gl.scenario_id = 'zero_emission'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C2_building_grid_proximity_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Analyze building proximity to electrical grid infrastructure by voltage level (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'efficiency_max'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'efficiency_max'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(ST_Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE ST_DWithin(bus_geom, b.building_geometry, 1000) \n          ORDER BY ST_Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "output_spatialite": "WITH grid_network AS (\n  SELECT gl.line_id, gl.from_bus, gl.to_bus, gl.length_km, gl.max_loading_percent,\n         ST_StartPoint(gl.geometry) as start_point,\n         ST_EndPoint(gl.geometry) as end_point,\n         gl.geometry as line_geom\n  FROM cim_vector.grid_line gl\n  WHERE gl.project_id = 'florence_heritage_area' AND gl.scenario_id = 'efficiency_max'\n),\nbus_connectivity AS (\n  SELECT gb.bus_id, gb.voltage_kv, gb.geometry as bus_geom,\n         COUNT(gn.line_id) as connected_lines\n  FROM cim_vector.grid_bus gb\n  LEFT JOIN grid_network gn ON gb.bus_id = gn.from_bus OR gb.bus_id = gn.to_bus\n  WHERE gb.project_id = 'florence_heritage_area' AND gb.scenario_id = 'efficiency_max'\n  GROUP BY gb.bus_id, gb.voltage_kv, gb.geometry\n),\nbuilding_grid_proximity AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.area,\n         bp.n_people,\n         MIN(Distance(b.building_geometry, bc.bus_geom)) as min_distance_to_bus,\n         (SELECT voltage_kv FROM bus_connectivity \n          WHERE Distance(bus_geom, b.building_geometry, 1000) \n          ORDER BY Distance(bus_geom, b.building_geometry) \n          LIMIT 1) as nearest_voltage_level\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  CROSS JOIN bus_connectivity bc\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY b.building_id, bp.type, bp.area, bp.n_people, b.building_geometry\n)\nSELECT type as building_type,\n       nearest_voltage_level,\n       COUNT(*) as building_count,\n       AVG(area) as avg_area,\n       SUM(n_people) as total_population,\n       AVG(min_distance_to_bus) as avg_distance_to_grid\nFROM building_grid_proximity\nWHERE nearest_voltage_level IS NOT NULL\nGROUP BY type, nearest_voltage_level\nORDER BY nearest_voltage_level DESC, building_count DESC;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "gb",
        "gn",
        "bc",
        "cim_vector",
        "gl"
      ],
      "tables": [
        "b.building_id",
        "gn.to_bus",
        "bc.bus_geom",
        "gl.length_km",
        "gl.line_id",
        "cim_vector.grid_line",
        "gl.geometry",
        "bp.building_id",
        "gl.max_loading_percent",
        "gb.bus_id",
        "bp.area",
        "gl.project_id",
        "gl.scenario_id",
        "building_grid_proximity",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gl.from_bus",
        "cim_vector.grid_bus",
        "grid_network",
        "gb.project_id",
        "bp.n_people",
        "gn.line_id",
        "gn.from_bus",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "bus_connectivity",
        "cim_vector.building",
        "gb.scenario_id",
        "gl.to_bus",
        "gb.voltage_kv"
      ],
      "columns": [
        "type",
        "n_people",
        "length_km",
        "line_id",
        "building_properties",
        "to_bus",
        "building_geometry",
        "geometry",
        "voltage_kv",
        "max_loading_percent",
        "building",
        "bus_geom",
        "from_bus",
        "bus_id",
        "grid_line",
        "grid_bus",
        "area"
      ],
      "functions": [
        "ST_DWithin",
        "ST_StartPoint",
        "ST_Distance",
        "ST_EndPoint"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 10\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 10\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'florence_heritage_area' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'florence_heritage_area' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'renewable_2030'\n  AND gb.voltage_kv >= 0.4\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'renewable_2030'\n  AND gb.voltage_kv >= 0.4\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "0",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "0.4",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "4",
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'rome_green_quarter' \n  AND gb.scenario_id = 'grid_modernization'\n  AND gb.voltage_kv >= 400\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'bologna_energy_hub' \n  AND gb.scenario_id = 'baseline'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'milan_smart_district' \n  AND gb.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'milan_smart_district' \n  AND gb.scenario_id = 'zero_emission'\n  AND gb.voltage_kv >= 220\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_A3_grid_buses_by_voltage_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Find active grid buses above certain voltage level in a project scenario (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "SELECT gb.bus_id, gb.name, gb.voltage_kv, ST_AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'florence_heritage_area' \n  AND gb.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 20\n  AND gb.in_service = true;",
    "output_spatialite": "SELECT gb.bus_id, gb.name, gb.voltage_kv, AsText(gb.geometry) as location\nFROM cim_vector.grid_bus gb\nWHERE gb.project_id = 'florence_heritage_area' \n  AND gb.scenario_id = 'efficiency_max'\n  AND gb.voltage_kv >= 20\n  AND gb.in_service = true;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "gb",
        "cim_vector"
      ],
      "tables": [
        "gb.geometry",
        "gb.name",
        "gb.in_service",
        "gb.bus_id",
        "cim_vector.grid_bus",
        "gb.scenario_id",
        "gb.project_id",
        "gb.voltage_kv"
      ],
      "columns": [
        "name",
        "geometry",
        "voltage_kv",
        "in_service",
        "bus_id",
        "grid_bus"
      ],
      "functions": [
        "ST_AsText"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.E1 >= 5\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.E1 >= 5\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 20\nORDER BY high_rise_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 20\nORDER BY high_rise_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 100;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 100;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 25;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Torino'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 25;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: efficiency_max)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Firenze'\n  AND c.E1 >= 20\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Firenze'\n  AND c.E1 >= 20\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Bologna'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.E1 >= 5\nORDER BY high_rise_percentage DESC\nLIMIT 50;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Milano'\n  AND c.E1 >= 5\nORDER BY high_rise_percentage DESC\nLIMIT 50;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_A6_building_structure_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Analyze building height distribution and interior complexity in census areas (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "output_spatialite": "SELECT c.SEZ2011, c.PROVINCIA, c.COMUNE,\n       c.E17 as single_floor_buildings,\n       c.E18 as two_floor_buildings,\n       c.E19 as three_floor_buildings,\n       c.E20 as four_plus_floor_buildings,\n       c.E21 as single_interior_buildings,\n       c.E22 as two_interior_buildings,\n       c.E26 as buildings_16plus_interiors,\n       c.E1 as total_buildings,\n       ROUND((c.E20::float / NULLIF(c.E1, 0)) * 100, 1) as high_rise_percentage,\n       ROUND((c.E26::float / NULLIF(c.E1, 0)) * 100, 1) as large_complex_percentage\nFROM cim_census.census_geo c\nWHERE c.PROVINCIA = 'Roma'\n  AND c.E1 >= 10\nORDER BY high_rise_percentage DESC\nLIMIT 10;",
    "complexity": "A",
    "usage_index": "low:vector",
    "evidence": {
      "schemas": [
        "cim_census",
        "c"
      ],
      "tables": [
        "c.SEZ2011",
        "c.E18",
        "c.E21",
        "c.E19",
        "c.COMUNE",
        "c.E22",
        "cim_census.census_geo",
        "c.E26",
        "c.PROVINCIA",
        "c.E1",
        "c.E20",
        "c.E17"
      ],
      "columns": [
        "E26",
        "E18",
        "census_geo",
        "PROVINCIA",
        "COMUNE",
        "SEZ2011",
        "E17",
        "E19",
        "E21",
        "E1",
        "E20",
        "E22"
      ],
      "functions": [],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: grid_modernization)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: florence_heritage_area, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'grid_modernization'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: renewable_2030)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: milan_smart_district, Scenario: renewable_2030)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C3_3d_raster_building_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: 3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "3D analysis of buildings using DTM and DSM raster data (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "WITH building_raster_stats AS (\n  SELECT b.building_id,\n         bp.type,\n         bp.height as declared_height,\n         ST_Value(dtm.rast, ST_Centroid(b.building_geometry)) as ground_elevation,\n         ST_Value(dsm.rast, ST_Centroid(b.building_geometry)) as surface_elevation,\n         ST_Area(b.building_geometry) as footprint_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(dtm.rast, b.building_geometry)\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(dsm.rast, b.building_geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'\n)\nSELECT type,\n       COUNT(*) as building_count,\n       AVG(declared_height) as avg_declared_height,\n       AVG(surface_elevation - ground_elevation) as avg_raster_height,\n       AVG(ground_elevation) as avg_ground_elevation,\n       SUM(footprint_area) as total_footprint_area,\n       AVG(ABS(declared_height - (surface_elevation - ground_elevation))) as avg_height_discrepancy\nFROM building_raster_stats\nWHERE ground_elevation IS NOT NULL AND surface_elevation IS NOT NULL\nGROUP BY type\nORDER BY avg_height_discrepancy DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "building_raster_stats",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "cim_vector.building",
        "dsm.rast",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Value",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'renewable_2030'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 500)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 20\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 500)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 10\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'milan_smart_district' AND gb.scenario_id = 'zero_emission'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 5\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'grid_modernization'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 5\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'baseline'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 500)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 20\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'efficiency_max'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 500)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 5\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'baseline'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 5000)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 20\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'bologna_energy_hub' AND gb.scenario_id = 'grid_modernization'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 1000)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 10\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: zero_emission)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: turin_innovation_zone, Scenario: zero_emission)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'zero_emission'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'turin_innovation_zone' AND gb.scenario_id = 'zero_emission'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 1000)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 20\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C5_integrated_census_grid_analysis_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Comprehensive analysis integrating building properties, census demographics, and electrical grid infrastructure for energy demand assessment (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH building_census_overlay AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as coverage_ratio\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_census.census_geo c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.7\n),\ngrid_proximity AS (\n  SELECT bco.building_id, bco.type, bco.height, bco.area, bco.n_people,\n         bco.REGIONE, bco.PROVINCIA, bco.total_population,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) as grid_distance,\n         ROW_NUMBER() OVER (PARTITION BY bco.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) as proximity_rank\n  FROM building_census_overlay bco\n  JOIN cim_vector.building b ON bco.building_id = b.building_id\n  JOIN cim_vector.grid_bus gb ON gb.project_id = 'rome_green_quarter' AND gb.scenario_id = 'baseline'\n  WHERE gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, 500)\n),\nenergy_analysis AS (\n  SELECT gp.building_id, gp.type, gp.height, gp.area, gp.n_people,\n         gp.REGIONE, gp.PROVINCIA, gp.total_population,\n         gp.grid_distance, gp.voltage_kv, gp.substation_name,\n         CASE \n           WHEN gp.type = 'industrial' THEN gp.area * 0.05  -- 50 W/sqm\n           WHEN gp.type = 'commercial' THEN gp.area * 0.03  -- 30 W/sqm  \n           WHEN gp.type = 'residential' THEN gp.n_people * 1.5  -- 1.5 kW per person\n           ELSE gp.area * 0.02\n         END as estimated_demand_kw,\n         CASE\n           WHEN gp.voltage_kv >= 10 THEN 'high_voltage'\n           WHEN gp.voltage_kv >= 1 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END as grid_level\n  FROM grid_proximity gp\n  WHERE gp.proximity_rank = 1\n)\nSELECT REGIONE, PROVINCIA, type, grid_level,\n       COUNT(*) as building_count,\n       ROUND(AVG(height), 1) as avg_height,\n       ROUND(SUM(area), 0) as total_area,\n       ROUND(SUM(estimated_demand_kw), 1) as total_demand_kw,\n       ROUND(AVG(grid_distance), 0) as avg_grid_distance,\n       ROUND(AVG(total_population), 0) as avg_census_population,\n       ROUND(SUM(estimated_demand_kw) / COUNT(*), 2) as demand_per_building\nFROM energy_analysis\nGROUP BY REGIONE, PROVINCIA, type, grid_level\nHAVING COUNT(*) >= 10\nORDER BY total_demand_kw DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "1",
        "gb",
        "gp",
        "bco",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "b.building_id",
        "c.SEZ2011",
        "gb.name",
        "gp.grid_distance",
        "gb.voltage_kv",
        "bco.n_people",
        "c.REGIONE",
        "gp.building_id",
        "gp.type",
        "gp.n_people",
        "energy_analysis",
        "bp.building_id",
        "gp.voltage_kv",
        "gb.in_service",
        "0.02",
        "gb.bus_id",
        "0.03",
        "bp.area",
        "c.COMUNE",
        "cim_census.census_geo",
        "bco.PROVINCIA",
        "0.05",
        "gp.substation_name",
        "building_census_overlay",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "gb.geometry",
        "gp.total_population",
        "1.5",
        "bco.REGIONE",
        "cim_vector.grid_bus",
        "gp.area",
        "gp.REGIONE",
        "gb.project_id",
        "bp.n_people",
        "c.P1",
        "bco.area",
        "cim_vector.building_properties",
        "bco.total_population",
        "gp.PROVINCIA",
        "gp.proximity_rank",
        "bp.scenario_id",
        "grid_proximity",
        "c.geometry",
        "gp.height",
        "bco.type",
        "cim_vector.building",
        "gb.scenario_id",
        "bp.height",
        "bco.height",
        "0.7",
        "bco.building_id"
      ],
      "columns": [
        "building_properties",
        "name",
        "geometry",
        "03",
        "in_service",
        "P1",
        "05",
        "n_people",
        "7",
        "total_population",
        "REGIONE",
        "voltage_kv",
        "building",
        "substation_name",
        "5",
        "type",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "02",
        "height",
        "grid_bus",
        "area",
        "grid_distance",
        "proximity_rank",
        "COMUNE",
        "bus_id"
      ],
      "functions": [
        "ST_Intersects",
        "ST_DWithin",
        "ST_Area",
        "ST_Intersection",
        "ST_Distance"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: renewable_2030)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: renewable_2030)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'renewable_2030'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: efficiency_max)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'efficiency_max'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Piemonte' AND c.P1 >= 500\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 3\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: zero_emission)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: florence_heritage_area, Scenario: zero_emission)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 1000\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'zero_emission'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Lombardia' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: milan_smart_district, Scenario: baseline)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: milan_smart_district, Scenario: baseline)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Emilia-Romagna' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'baseline'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C4_urban_morphology_classification_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: baseline)",
    "input": "Advanced urban morphology classification combining census demographics with building density for urban planning insights (Project: bologna_energy_hub, Scenario: baseline)",
    "output_postgis": "WITH demographic_density_analysis AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE, c.geometry,\n         c.P1 as total_population,\n         c.P14 + c.P15 + c.P16 as children_0_14,\n         c.P27 + c.P28 + c.P29 as elderly_65_plus,\n         c.PF3 as single_person_families,\n         c.PF8 as large_families_6plus,\n         c.A2 as occupied_homes,\n         ST_Area(c.geometry) as census_area_sqm\n  FROM cim_census.census_geo c\n  WHERE c.REGIONE = 'Toscana' AND c.P1 >= 100\n),\nbuilding_density_overlay AS (\n  SELECT dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n         dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n         dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n         dda.census_area_sqm,\n         COUNT(b.building_id) as buildings_in_area,\n         SUM(bp.area) as total_building_footprint,\n         AVG(bp.height) as avg_building_height,\n         SUM(bp.n_people) as building_residents\n  FROM demographic_density_analysis dda\n  LEFT JOIN cim_vector.building b ON ST_Within(ST_Centroid(b.building_geometry), dda.geometry)\n  LEFT JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'baseline'\n  GROUP BY dda.SEZ2011, dda.REGIONE, dda.PROVINCIA, dda.COMUNE,\n           dda.total_population, dda.children_0_14, dda.elderly_65_plus,\n           dda.single_person_families, dda.large_families_6plus, dda.occupied_homes,\n           dda.census_area_sqm\n),\ndensity_indicators AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         total_population, buildings_in_area, avg_building_height,\n         ROUND((total_population::float / (census_area_sqm / 10000)), 1) as population_density_per_hectare,\n         ROUND((total_building_footprint::float / census_area_sqm) * 100, 1) as building_coverage_pct,\n         ROUND((children_0_14::float / NULLIF(total_population, 0)) * 100, 1) as child_ratio,\n         ROUND((elderly_65_plus::float / NULLIF(total_population, 0)) * 100, 1) as elderly_ratio,\n         ROUND((single_person_families::float / NULLIF(occupied_homes, 0)) * 100, 1) as single_household_pct,\n         CASE \n           WHEN buildings_in_area > 0 THEN ROUND((building_residents::float / NULLIF(buildings_in_area, 0)), 1)\n           ELSE 0\n         END as avg_residents_per_building\n  FROM building_density_overlay\n  WHERE census_area_sqm > 0\n),\nurban_morphology_classification AS (\n  SELECT SEZ2011, REGIONE, PROVINCIA, COMUNE,\n         population_density_per_hectare, building_coverage_pct, child_ratio, elderly_ratio,\n         single_household_pct, avg_residents_per_building,\n         CASE \n           WHEN population_density_per_hectare > 150 AND building_coverage_pct > 30 THEN 'DENSE_URBAN_CORE'\n           WHEN population_density_per_hectare > 100 AND elderly_ratio > 25 THEN 'AGING_DENSE_NEIGHBORHOOD'\n           WHEN population_density_per_hectare > 80 AND child_ratio > 20 THEN 'FAMILY_ORIENTED_DISTRICT'\n           WHEN population_density_per_hectare < 50 AND single_household_pct > 40 THEN 'SUBURBAN_SINGLES'\n           WHEN building_coverage_pct < 15 AND population_density_per_hectare < 30 THEN 'RURAL_SPARSE'\n           ELSE 'MIXED_RESIDENTIAL'\n         END as urban_morphology_type\n  FROM density_indicators\n)\nSELECT urban_morphology_type, PROVINCIA,\n       COUNT(*) as areas_count,\n       ROUND(AVG(population_density_per_hectare), 1) as avg_pop_density,\n       ROUND(AVG(building_coverage_pct), 1) as avg_building_coverage,\n       ROUND(AVG(child_ratio), 1) as avg_child_ratio,\n       ROUND(AVG(elderly_ratio), 1) as avg_elderly_ratio,\n       ROUND(AVG(single_household_pct), 1) as avg_single_households,\n       ROUND(AVG(avg_residents_per_building), 1) as avg_residents_per_bldg\nFROM urban_morphology_classification\nGROUP BY urban_morphology_type, PROVINCIA\nHAVING COUNT(*) >= 5\nORDER BY avg_pop_density DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "dda",
        "cim_vector",
        "c",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.P15",
        "dda.PROVINCIA",
        "c.P16",
        "dda.COMUNE",
        "c.REGIONE",
        "dda.geometry",
        "c.P29",
        "bp.building_id",
        "c.PF3",
        "bp.area",
        "c.COMUNE",
        "dda.single_person_families",
        "cim_census.census_geo",
        "c.PROVINCIA",
        "dda.large_families_6plus",
        "bp.project_id",
        "b.building_geometry",
        "demographic_density_analysis",
        "building_density_overlay",
        "c.PF8",
        "density_indicators",
        "urban_morphology_classification",
        "dda.children_0_14",
        "bp.height",
        "dda.total_population",
        "dda.census_area_sqm",
        "c.P28",
        "c.P27",
        "bp.n_people",
        "c.P14",
        "c.P1",
        "dda.occupied_homes",
        "cim_vector.building_properties",
        "dda.elderly_65_plus",
        "bp.scenario_id",
        "c.geometry",
        "dda.SEZ2011",
        "cim_vector.building",
        "c.A2",
        "dda.REGIONE"
      ],
      "columns": [
        "building_properties",
        "PF3",
        "geometry",
        "P1",
        "P14",
        "PF8",
        "n_people",
        "total_population",
        "REGIONE",
        "building",
        "P29",
        "P16",
        "census_area_sqm",
        "single_person_families",
        "P27",
        "large_families_6plus",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "P28",
        "occupied_homes",
        "SEZ2011",
        "height",
        "area",
        "children_0_14",
        "P15",
        "COMUNE",
        "A2",
        "elderly_65_plus"
      ],
      "functions": [
        "ST_Within",
        "ST_Area",
        "ST_Centroid"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: baseline)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: baseline)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'baseline'\n    AND c.REGIONE = 'Lazio'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 5\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'\n    AND c.REGIONE = 'Toscana'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 20\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n    AND c.REGIONE = 'Piemonte'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 5\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n    AND c.REGIONE = 'Toscana'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 20\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n    AND c.REGIONE = 'Toscana'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 20\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n    AND c.REGIONE = 'Toscana'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 20\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n    AND c.REGIONE = 'Lazio'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 5\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: milan_smart_district, Scenario: zero_emission)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: milan_smart_district, Scenario: zero_emission)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'milan_smart_district' AND bp.scenario_id = 'zero_emission'\n    AND c.REGIONE = 'Lazio'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 5\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'\n    AND c.REGIONE = 'Lazio'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 10\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_CENSUS_C3_socioeconomic_building_integration_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "input": "Integrate census socioeconomic data with building properties for comprehensive urban profiling and development analysis (Project: turin_innovation_zone, Scenario: grid_modernization)",
    "output_postgis": "WITH census_building_overlay AS (\n  SELECT c.SEZ2011, c.REGIONE, c.PROVINCIA, c.COMUNE,\n         c.P1 as census_population,\n         c.P47 as university_graduates,\n         c.P61 as employed_residents,\n         c.A47 as owned_families,\n         c.PF1 as total_families,\n         c.E3 as residential_buildings_census,\n         b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) as overlap_ratio\n  FROM cim_census.census_geo c\n  JOIN cim_vector.building b ON ST_Intersects(b.building_geometry, c.geometry)\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'grid_modernization'\n    AND c.REGIONE = 'Lazio'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.6\n),\nsocioeconomic_building_profile AS (\n  SELECT cbo.SEZ2011, cbo.REGIONE, cbo.PROVINCIA, cbo.COMUNE,\n         cbo.building_id, cbo.type, cbo.height, cbo.area, cbo.n_people,\n         cbo.census_population, cbo.university_graduates, cbo.employed_residents,\n         ROUND((cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) * 100, 1) as education_index,\n         ROUND((cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) * 100, 1) as employment_index,\n         ROUND((cbo.owned_families::float / NULLIF(cbo.total_families, 0)) * 100, 1) as ownership_rate,\n         CASE \n           WHEN cbo.type = 'residential' AND (cbo.university_graduates::float / NULLIF(cbo.census_population, 0)) > 0.25 THEN 'HIGH_EDUCATION_RESIDENTIAL'\n           WHEN cbo.type = 'commercial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.70 THEN 'ACTIVE_COMMERCIAL_ZONE'\n           WHEN cbo.type = 'industrial' AND (cbo.employed_residents::float / NULLIF(cbo.census_population, 0)) > 0.65 THEN 'INDUSTRIAL_EMPLOYMENT_HUB'\n           ELSE 'STANDARD_MIXED_USE'\n         END as socioeconomic_profile\n  FROM census_building_overlay cbo\n)\nSELECT socioeconomic_profile, PROVINCIA,\n       COUNT(DISTINCT building_id) as buildings_count,\n       COUNT(DISTINCT SEZ2011) as census_areas_count,\n       ROUND(AVG(education_index), 1) as avg_education_index,\n       ROUND(AVG(employment_index), 1) as avg_employment_index,\n       ROUND(AVG(ownership_rate), 1) as avg_ownership_rate,\n       ROUND(AVG(height), 1) as avg_building_height,\n       ROUND(SUM(area), 0) as total_building_area,\n       SUM(n_people) as total_building_residents\nFROM socioeconomic_building_profile\nGROUP BY socioeconomic_profile, PROVINCIA\nHAVING COUNT(DISTINCT building_id) >= 10\nORDER BY avg_education_index DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "b",
        "cbo",
        "cim_vector",
        "c",
        "0",
        "cim_census"
      ],
      "tables": [
        "c.SEZ2011",
        "b.building_id",
        "c.PF1",
        "c.REGIONE",
        "c.P47",
        "0.6",
        "c.P61",
        "bp.building_id",
        "cbo.census_population",
        "cbo.COMUNE",
        "cbo.PROVINCIA",
        "bp.area",
        "cbo.type",
        "0.25",
        "c.COMUNE",
        "cbo.university_graduates",
        "cim_census.census_geo",
        "cbo.REGIONE",
        "c.PROVINCIA",
        "bp.project_id",
        "bp.type",
        "b.building_geometry",
        "cbo.height",
        "c.E3",
        "cbo.total_families",
        "census_building_overlay",
        "cbo.employed_residents",
        "c.A47",
        "cbo.SEZ2011",
        "cbo.area",
        "cbo.owned_families",
        "bp.n_people",
        "c.P1",
        "cbo.building_id",
        "0.65",
        "cim_vector.building_properties",
        "bp.scenario_id",
        "c.geometry",
        "cbo.n_people",
        "cim_vector.building",
        "0.70",
        "bp.height",
        "socioeconomic_building_profile"
      ],
      "columns": [
        "P61",
        "building_properties",
        "geometry",
        "70",
        "census_population",
        "P1",
        "n_people",
        "university_graduates",
        "E3",
        "6",
        "employed_residents",
        "REGIONE",
        "building",
        "owned_families",
        "type",
        "25",
        "building_geometry",
        "census_geo",
        "PROVINCIA",
        "SEZ2011",
        "PF1",
        "A47",
        "height",
        "area",
        "COMUNE",
        "65",
        "P47",
        "total_families"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_1",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: renewable_2030)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'renewable_2030'\n    AND bp.type = 'industrial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 9\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_2",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: renewable_2030)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'renewable_2030'\n    AND bp.type = 'mixed_use'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 3\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_3",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: baseline)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: baseline)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'baseline'\n    AND bp.type = 'residential'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 6\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_4",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: florence_heritage_area, Scenario: efficiency_max)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: florence_heritage_area, Scenario: efficiency_max)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'florence_heritage_area' AND bp.scenario_id = 'efficiency_max'\n    AND bp.type = 'commercial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 9\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_5",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: renewable_2030)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: renewable_2030)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'renewable_2030'\n    AND bp.type = 'industrial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 7\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_6",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'grid_modernization'\n    AND bp.type = 'mixed_use'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 8\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_7",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: efficiency_max)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: efficiency_max)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'efficiency_max'\n    AND bp.type = 'commercial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 3\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_8",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: baseline)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: turin_innovation_zone, Scenario: baseline)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'turin_innovation_zone' AND bp.scenario_id = 'baseline'\n    AND bp.type = 'commercial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 6\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_9",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: grid_modernization)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: rome_green_quarter, Scenario: grid_modernization)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'rome_green_quarter' AND bp.scenario_id = 'grid_modernization'\n    AND bp.type = 'commercial'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 7\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  },
  {
    "id": "CIM_C4_precise_building_height_raster_var_10",
    "instruction": "Convert this natural language description to spatial SQL: Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: zero_emission)",
    "input": "Calculate precise building heights by clipping DSM and DTM rasters with building footprints and computing elevation differences (Project: bologna_energy_hub, Scenario: zero_emission)",
    "output_postgis": "WITH building_raster_intersections AS (\n  SELECT b.building_id, bp.type, bp.height as declared_height,\n         ST_Intersection(b.building_geometry, dsm.rast) as dsm_clip,\n         ST_Intersection(b.building_geometry, dtm.rast) as dtm_clip,\n         ST_Area(b.building_geometry) as building_area\n  FROM cim_vector.building b\n  JOIN cim_vector.building_properties bp ON b.building_id = bp.building_id\n  JOIN cim_raster.dsm_raster dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  JOIN cim_raster.dtm_raster dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE bp.project_id = 'bologna_energy_hub' AND bp.scenario_id = 'zero_emission'\n    AND bp.type = 'mixed_use'\n),\nheight_calculations AS (\n  SELECT building_id, type, declared_height,\n         (ST_SummaryStats(dsm_clip)).mean as avg_dsm_elevation,\n         (ST_SummaryStats(dtm_clip)).mean as avg_dtm_elevation,\n         building_area,\n         (ST_SummaryStats(dsm_clip)).count as dsm_pixel_count,\n         (ST_SummaryStats(dtm_clip)).count as dtm_pixel_count\n  FROM building_raster_intersections\n  WHERE dsm_clip IS NOT NULL AND dtm_clip IS NOT NULL\n)\nSELECT building_id, type, declared_height, building_area,\n       ROUND(avg_dsm_elevation, 2) as surface_elevation,\n       ROUND(avg_dtm_elevation, 2) as ground_elevation,\n       ROUND((avg_dsm_elevation - avg_dtm_elevation), 2) as calculated_height,\n       ROUND(ABS(declared_height - (avg_dsm_elevation - avg_dtm_elevation)), 2) as height_difference,\n       dsm_pixel_count, dtm_pixel_count\nFROM height_calculations\nWHERE avg_dsm_elevation IS NOT NULL AND avg_dtm_elevation IS NOT NULL\n  AND (avg_dsm_elevation - avg_dtm_elevation) > 5\nORDER BY height_difference DESC;",
    "output_spatialite": "-- Not available in SpatiaLite (raster operations)",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "schemas": [
        "bp",
        "dtm",
        "b",
        "cim_vector",
        "cim_raster",
        "dsm"
      ],
      "tables": [
        "b.building_id",
        "bp.building_id",
        "cim_vector.building_properties",
        "dtm.rast",
        "bp.scenario_id",
        "cim_raster.dsm_raster",
        "building_raster_intersections",
        "cim_vector.building",
        "dsm.rast",
        "height_calculations",
        "bp.height",
        "cim_raster.dtm_raster",
        "bp.project_id",
        "bp.type",
        "b.building_geometry"
      ],
      "columns": [
        "type",
        "dtm_raster",
        "count",
        "building_properties",
        "building_geometry",
        "rast",
        "building",
        "dsm_raster",
        "height",
        "mean"
      ],
      "functions": [
        "ST_Intersects",
        "ST_Area",
        "ST_SummaryStats",
        "ST_Intersection"
      ],
      "template_source": "cim_wizard"
    }
  }
]
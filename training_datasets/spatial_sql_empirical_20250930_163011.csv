id,instruction,input,output_postgis,output_spatialite,complexity,usage_index,evidence_schemas,evidence_tables,evidence_functions
A1_point_in_polygon,Convert this natural language description to spatial SQL: Find all areas that contain a specific point,Find all areas that contain a specific point,"SELECT a.{id_col}, a.{attr_cols}
FROM {areas_table} a
JOIN {points_table} p
  ON ST_Intersects(p.{geom}, a.{geom})
WHERE p.{id_col} = {point_id};","SELECT a.{id_col}, a.{attr_cols}
FROM {areas_table} a
JOIN {points_table} p
  ON Intersects(p.{geom}, a.{geom})
WHERE p.{id_col} = {point_id};",A,critical:vector,,,ST_Intersects
A2_distance_filter,Convert this natural language description to spatial SQL: Find features within a certain distance of a point,Find features within a certain distance of a point,"SELECT f.*
FROM {features} f
WHERE ST_DWithin(
  f.{geom}::geography,
  ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})::geography,
  {meters}
);","SELECT f.*
FROM {features} f
WHERE Distance(
  f.{geom},
  SetSRID(MakePoint({lon}, {lat}), {srid}),
  {meters}
);",A,very_high:vector,,,"ST_MakePoint,ST_DWithin,ST_SetSRID"
A3_knn_nearest,Convert this natural language description to spatial SQL: Find the k nearest features to a given point,Find the k nearest features to a given point,"SELECT f.*
FROM {features} f
ORDER BY f.{geom} <-> ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})
LIMIT {k};","SELECT f.*
FROM {features} f
ORDER BY f.{geom} SetSRID(MakePoint({lon}, {lat}), {srid})
LIMIT {k};",A,very_high:vector,,,"ST_MakePoint,ST_SetSRID"
A4_basic_buffer,Convert this natural language description to spatial SQL: Create a buffer around features,Create a buffer around features,"SELECT {id_col}, ST_Buffer({geom}, {buffer_distance}) AS buffered_geom
FROM {features};","SELECT {id_col}, Buffer({geom}, {buffer_distance}) AS buffered_geom
FROM {features};",A,very_high:vector,,,ST_Buffer
A5_area_calculation,Convert this natural language description to spatial SQL: Calculate area of polygon features,Calculate area of polygon features,"SELECT {id_col}, ST_Area({geom}) AS area_sqm
FROM {polygons}
ORDER BY area_sqm DESC;","SELECT {id_col}, Area({geom}) AS area_sqm
FROM {polygons}
ORDER BY area_sqm DESC;",A,critical:vector,,,ST_Area
A6_length_calculation,Convert this natural language description to spatial SQL: Calculate length of line features,Calculate length of line features,"SELECT {id_col}, ST_Length({geom}) AS length_m
FROM {lines}
ORDER BY length_m DESC;","SELECT {id_col}, GLength({geom}) AS length_m
FROM {lines}
ORDER BY length_m DESC;",A,very_high:vector,,,ST_Length
B1_spatial_join_count,Convert this natural language description to spatial SQL: Count points within each polygon area,Count points within each polygon area,"SELECT a.{id_col}, COUNT(p.*) AS n_points
FROM {areas} a
LEFT JOIN {points} p
  ON ST_Intersects(p.{geom}, a.{geom})
GROUP BY a.{id_col};","SELECT a.{id_col}, COUNT(p.*) AS n_points
FROM {areas} a
LEFT JOIN {points} p
  ON Intersects(p.{geom}, a.{geom})
GROUP BY a.{id_col};",B,critical:vector,,,ST_Intersects
B2_reproject_buffer_join,"Convert this natural language description to spatial SQL: Reproject lines, buffer them, and find intersecting sites","Reproject lines, buffer them, and find intersecting sites","WITH proj AS (
  SELECT id, ST_Transform({geom}, {target_srid}) AS g FROM {lines}
)
SELECT s.*
FROM {sites} s
JOIN proj l
  ON ST_DWithin(s.{geom}, ST_Buffer(l.g, {buffer_units}), 0);","WITH proj AS (
  SELECT id, Transform({geom}, {target_srid}) AS g FROM {lines}
)
SELECT s.*
FROM {sites} s
JOIN proj l
  ON Distance(s.{geom}, Buffer(l.g, {buffer_units}), 0);",B,very_high:vector,l,"proj,l.g","ST_Transform,ST_DWithin,ST_Buffer"
B3_dissolve_by_category,Convert this natural language description to spatial SQL: Merge polygons by category using union operation,Merge polygons by category using union operation,"SELECT {category}, ST_Union({geom}) AS geom
FROM {polygons}
GROUP BY {category};","SELECT {category}, ST_Union({geom}) AS geom
FROM {polygons}
GROUP BY {category};",B,high:vector,,,ST_Union
B4_makevalid_overlay,Convert this natural language description to spatial SQL: Clean invalid geometries and calculate intersection areas,Clean invalid geometries and calculate intersection areas,"WITH clean AS (
  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}
)
SELECT ST_Area(ST_Intersection(c.g, o.{geom})) AS inter_area
FROM clean c
JOIN {other} o
  ON ST_Intersects(c.g, o.{geom});","WITH clean AS (
  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}
)
SELECT Area(Intersection(c.g, o.{geom})) AS inter_area
FROM clean c
JOIN {other} o
  ON Intersects(c.g, o.{geom});",B,critical:vector,c,"c.g,clean","ST_Area,ST_MakeValid,ST_Intersects,ST_Intersection"
B5_spatial_aggregation,Convert this natural language description to spatial SQL: Aggregate spatial features by administrative boundary,Aggregate spatial features by administrative boundary,"SELECT admin.{admin_name},
       COUNT(f.*) AS feature_count,
       AVG(ST_Area(f.{geom})) AS avg_area
FROM {features} f
JOIN {admin_boundaries} admin
  ON ST_Within(f.{geom}, admin.{geom})
GROUP BY admin.{admin_name};","SELECT admin.{admin_name},
       COUNT(f.*) AS feature_count,
       AVG(Area(f.{geom})) AS avg_area
FROM {features} f
JOIN {admin_boundaries} admin
  ON Within(f.{geom}, admin.{geom})
GROUP BY admin.{admin_name};",B,critical:vector,,,"ST_Area,ST_Within"
B6_convex_hull_analysis,Convert this natural language description to spatial SQL: Create convex hull around grouped points,Create convex hull around grouped points,"SELECT {group_col}, 
       ST_ConvexHull(ST_Collect({geom})) AS hull_geom,
       COUNT(*) AS point_count
FROM {points}
GROUP BY {group_col};","SELECT {group_col}, 
       ConvexHull(ST_Collect({geom})) AS hull_geom,
       COUNT(*) AS point_count
FROM {points}
GROUP BY {group_col};",B,medium:vector,,,"ST_Collect,ST_ConvexHull"
C10_grid_building_proximity,Convert this natural language description to spatial SQL: Analyze electrical grid infrastructure proximity to buildings with voltage level considerations,Analyze electrical grid infrastructure proximity to buildings with voltage level considerations,"WITH building_grid_proximity AS (
  SELECT b.building_id, bp.type, bp.height, bp.area,
         gb.bus_id, gb.voltage_kv, gb.name as substation_name,
         ST_Distance(b.building_geometry, gb.geometry) AS distance_to_grid,
         RANK() OVER (PARTITION BY b.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) AS proximity_rank
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id  
  JOIN {grid_bus} gb ON gb.project_id = bp.project_id AND gb.scenario_id = bp.scenario_id
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
    AND gb.in_service = true
    AND ST_DWithin(b.building_geometry, gb.geometry, {max_distance})
),
voltage_requirements AS (
  SELECT building_id, type, height, area,
         CASE 
           WHEN type IN ('industrial', 'commercial') AND area > 1000 THEN 'high_voltage'
           WHEN type = 'residential' AND height > 20 THEN 'medium_voltage'
           ELSE 'low_voltage'
         END AS required_voltage_level
  FROM building_grid_proximity
  WHERE proximity_rank = 1
)
SELECT bgp.building_id, bgp.type, bgp.distance_to_grid,
       bgp.voltage_kv, bgp.substation_name,
       vr.required_voltage_level,
       CASE 
         WHEN vr.required_voltage_level = 'high_voltage' AND bgp.voltage_kv >= 10 THEN 'adequate'
         WHEN vr.required_voltage_level = 'medium_voltage' AND bgp.voltage_kv >= 1 THEN 'adequate'
         WHEN vr.required_voltage_level = 'low_voltage' AND bgp.voltage_kv >= 0.4 THEN 'adequate'
         ELSE 'insufficient'
       END AS grid_adequacy
FROM building_grid_proximity bgp
JOIN voltage_requirements vr ON bgp.building_id = vr.building_id
WHERE bgp.proximity_rank = 1
ORDER BY bgp.distance_to_grid;",-- Not available in SpatiaLite,C,critical:vector,"0,bgp,vr,gb,b,bp","bgp.distance_to_grid,gb.name,bgp.substation_name,vr.required_voltage_level,gb.geometry,bgp.proximity_rank,gb.bus_id,bgp.type,building_grid_proximity,gb.project_id,gb.in_service,bp.height,bp.scenario_id,bgp.building_id,bp.area,voltage_requirements,bp.project_id,0.4,b.building_id,b.building_geometry,gb.scenario_id,bp.type,bp.building_id,vr.building_id,bgp.voltage_kv,gb.voltage_kv","ST_DWithin,ST_Distance"
C11_multi_schema_spatial_analysis,"Convert this natural language description to spatial SQL: Comprehensive spatial analysis across vector, census, and building data with distance-based clustering","Comprehensive spatial analysis across vector, census, and building data with distance-based clustering","WITH spatial_clusters AS (
  SELECT b.building_id, bp.type, bp.n_people,
         c.SEZ2011, c.P1 as population, c.REGIONE,
         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) 
         OVER (PARTITION BY bp.type) AS cluster_id
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON ST_Within(ST_Centroid(b.building_geometry), c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
),
cluster_stats AS (
  SELECT cluster_id, type, REGIONE,
         COUNT(*) AS building_count,
         SUM(n_people) AS total_residents,
         AVG(population) AS avg_census_population,
         ST_ConvexHull(ST_Collect(ST_Centroid(b.building_geometry))) AS cluster_boundary
  FROM spatial_clusters sc
  JOIN {buildings} b ON sc.building_id = b.building_id
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, type, REGIONE
  HAVING COUNT(*) >= {min_cluster_size}
)
SELECT cluster_id, type, REGIONE, building_count, total_residents,
       ROUND(avg_census_population, 0) AS avg_census_pop,
       ST_Area(cluster_boundary) AS cluster_area_sqm,
       ROUND(total_residents::float / (ST_Area(cluster_boundary) / 10000), 2) AS density_per_hectare
FROM cluster_stats
ORDER BY density_per_hectare DESC;","WITH spatial_clusters AS (
  SELECT b.building_id, bp.type, bp.n_people,
         c.SEZ2011, c.P1 as population, c.REGIONE,
         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) 
         OVER (PARTITION BY bp.type) AS cluster_id
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON Within(Centroid(b.building_geometry), c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
),
cluster_stats AS (
  SELECT cluster_id, type, REGIONE,
         COUNT(*) AS building_count,
         SUM(n_people) AS total_residents,
         AVG(population) AS avg_census_population,
         ConvexHull(ST_Collect(Centroid(b.building_geometry))) AS cluster_boundary
  FROM spatial_clusters sc
  JOIN {buildings} b ON sc.building_id = b.building_id
  WHERE cluster_id IS NOT NULL
  GROUP BY cluster_id, type, REGIONE
  HAVING COUNT(*) >= {min_cluster_size}
)
SELECT cluster_id, type, REGIONE, building_count, total_residents,
       ROUND(avg_census_population, 0) AS avg_census_pop,
       Area(cluster_boundary) AS cluster_area_sqm,
       ROUND(total_residents::float / (Area(cluster_boundary) / 10000), 2) AS density_per_hectare
FROM cluster_stats
ORDER BY density_per_hectare DESC;",C,critical:clustering,"c,b,bp,sc","bp.scenario_id,cluster_stats,b.building_id,b.building_geometry,sc.building_id,c.REGIONE,spatial_clusters,c.SEZ2011,bp.type,bp.project_id,bp.n_people,bp.building_id,c.geometry,c.P1","ST_Collect,ST_Area,ST_ConvexHull,ST_Within,ST_Centroid,ST_ClusterDBSCAN"
C1_knn_per_group,Convert this natural language description to spatial SQL: Find k nearest neighbors for each point in a group,Find k nearest neighbors for each point in a group,"SELECT *
FROM (
  SELECT p.id AS p_id, f.id AS f_id,
         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} <-> p.{geom}) AS rk
  FROM {points} p
  JOIN {features} f ON TRUE
) x
WHERE rk <= {k};","SELECT *
FROM (
  SELECT p.id AS p_id, f.id AS f_id,
         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} p.{geom}) AS rk
  FROM {points} p
  JOIN {features} f ON TRUE
) x
WHERE rk <= {k};",C,low:vector,"f,p","p.id,f.id",
C2_linear_referencing,Convert this natural language description to spatial SQL: Project point onto line and split line at that location,Project point onto line and split line at that location,"WITH s AS (
  SELECT l.id, ST_LineLocatePoint(l.{geom}, ST_SetSRID(ST_MakePoint({lon},{lat}),{srid})) AS frac
  FROM {lines} l WHERE l.id = {line_id}
)
SELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,
       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end
FROM {lines} l
JOIN s ON s.id = l.id;","WITH s AS (
  SELECT l.id, ST_LineLocatePoint(l.{geom}, SetSRID(MakePoint({lon},{lat}),{srid})) AS frac
  FROM {lines} l WHERE l.id = {line_id}
)
SELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,
       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end
FROM {lines} l
JOIN s ON s.id = l.id;",C,very_high:vector,"l,s","l.id,s.id,s.frac","ST_LineLocatePoint,ST_MakePoint,ST_LineSubstring,ST_SetSRID"
C3_cluster_analysis,Convert this natural language description to spatial SQL: Perform DBSCAN clustering on point locations,Perform DBSCAN clustering on point locations,"SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *
FROM {points};","SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *
FROM {points};",C,low:clustering,,,ST_ClusterDBSCAN
C4_topology_analysis,Convert this natural language description to spatial SQL: Analyze topological relationships between polygon features,Analyze topological relationships between polygon features,"SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,
       CASE 
         WHEN ST_Contains(a.{geom}, b.{geom}) THEN 'contains'
         WHEN ST_Within(a.{geom}, b.{geom}) THEN 'within'
         WHEN ST_Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'
         WHEN ST_Touches(a.{geom}, b.{geom}) THEN 'touches'
         ELSE 'disjoint'
       END AS relationship
FROM {polygons} a
JOIN {polygons} b ON a.{id_col} != b.{id_col}
WHERE ST_Intersects(a.{geom}, b.{geom}) OR ST_Touches(a.{geom}, b.{geom});","SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,
       CASE 
         WHEN Contains(a.{geom}, b.{geom}) THEN 'contains'
         WHEN Within(a.{geom}, b.{geom}) THEN 'within'
         WHEN Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'
         WHEN Touches(a.{geom}, b.{geom}) THEN 'touches'
         ELSE 'disjoint'
       END AS relationship
FROM {polygons} a
JOIN {polygons} b ON a.{id_col} != b.{id_col}
WHERE Intersects(a.{geom}, b.{geom}) OR Touches(a.{geom}, b.{geom});",C,critical:topology,,,"ST_Overlaps,ST_Intersects,ST_Within,ST_Contains,ST_Touches"
C5_network_analysis,Convert this natural language description to spatial SQL: Find connected components in a line network,Find connected components in a line network,"WITH nodes AS (
  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom
  FROM {lines}
),
connected AS (
  SELECT ST_ClusterIntersecting(node_geom) AS component
  FROM nodes
)
SELECT ROW_NUMBER() OVER () AS component_id, 
       ST_NumGeometries(component) AS node_count
FROM connected;","WITH nodes AS (
  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom
  FROM {lines}
),
connected AS (
  SELECT ST_ClusterIntersecting(node_geom) AS component
  FROM nodes
)
SELECT ROW_NUMBER() OVER () AS component_id, 
       ST_NumGeometries(component) AS node_count
FROM connected;",C,medium:network,,"connected,nodes","ST_ClusterIntersecting,ST_NumGeometries,ST_StartPoint,ST_EndPoint"
C6_raster_analysis,Convert this natural language description to spatial SQL: Extract raster values at point locations,Extract raster values at point locations,"SELECT p.id, ST_Value(r.rast, 1, p.{geom}) AS elevation
FROM {raster_table} r
JOIN {points} p
  ON ST_Intersects(r.rast, p.{geom});",-- Not available in SpatiaLite,C,critical:raster,"p,r","p.id,r.rast","ST_Value,ST_Intersects"
C6_spatial_index_query,Convert this natural language description to spatial SQL: Efficient spatial query using spatial index,Efficient spatial query using spatial index,-- Not available in PostGIS,"SELECT f.*
FROM {features} f
WHERE f.ROWID IN (
  SELECT ROWID FROM SpatialIndex 
  WHERE f_table_name = '{features}' 
  AND search_frame = BuildMbr({xmin}, {ymin}, {xmax}, {ymax}, {srid})
);",C,low:vector,f,"f.ROWID,SpatialIndex",
C7_3d_analysis,Convert this natural language description to spatial SQL: Calculate 3D distances between points with elevation,Calculate 3D distances between points with elevation,"SELECT a.{id_col}, b.{id_col},
       ST_3DDistance(a.{geom}, b.{geom}) AS distance_3d
FROM {points_3d} a
JOIN {points_3d} b ON a.{id_col} != b.{id_col}
WHERE ST_3DDistance(a.{geom}, b.{geom}) < {max_distance};",-- Not available in SpatiaLite,C,low:3d,,,ST_3DDistance
C8_building_height_raster_analysis,Convert this natural language description to spatial SQL: Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference,Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference,"WITH building_dsm AS (
  SELECT b.building_id, b.building_geometry,
         AVG(ST_Value(dsm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dsm.rast)))) AS avg_dsm_height
  FROM {buildings} b
  JOIN {dsm_raster} dsm ON ST_Intersects(b.building_geometry, dsm.rast)
  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'
  GROUP BY b.building_id, b.building_geometry
),
building_dtm AS (
  SELECT b.building_id,
         AVG(ST_Value(dtm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dtm.rast)))) AS avg_dtm_height
  FROM {buildings} b
  JOIN {dtm_raster} dtm ON ST_Intersects(b.building_geometry, dtm.rast)
  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'
  GROUP BY b.building_id
)
SELECT dsm.building_id, dsm.building_geometry,
       dsm.avg_dsm_height, dtm.avg_dtm_height,
       ROUND((dsm.avg_dsm_height - dtm.avg_dtm_height), 2) AS calculated_height,
       ST_Area(dsm.building_geometry) AS building_area
FROM building_dsm dsm
JOIN building_dtm dtm ON dsm.building_id = dtm.building_id
WHERE (dsm.avg_dsm_height - dtm.avg_dtm_height) > {min_height};",-- Not available in SpatiaLite,C,critical:raster,"dsm,dtm,b","b.scenario_id,b.building_id,b.building_geometry,dsm.avg_dsm_height,dtm.building_id,building_dtm,dsm.building_geometry,dsm.rast,dtm.rast,dsm.building_id,dtm.avg_dtm_height,building_dsm,b.project_id","ST_Area,ST_Intersects,ST_Centroid,ST_Value,ST_Intersection"
C9_census_building_correlation,Convert this natural language description to spatial SQL: Correlate building properties with census data by spatial overlay analysis,Correlate building properties with census data by spatial overlay analysis,"WITH building_census AS (
  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,
         c.SEZ2011, c.P1 as total_population, c.ST1 as total_households,
         c.REGIONE, c.PROVINCIA, c.COMUNE,
         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) AS overlap_ratio
  FROM {buildings} b
  JOIN {building_properties} bp ON b.building_id = bp.building_id
  JOIN {census_geo} c ON ST_Intersects(b.building_geometry, c.geometry)
  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'
    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.5
),
aggregated_stats AS (
  SELECT REGIONE, PROVINCIA, bp.type,
         COUNT(*) AS building_count,
         AVG(bp.height) AS avg_building_height,
         SUM(bp.area) AS total_building_area,
         AVG(bc.total_population::float / NULLIF(bc.total_households, 0)) AS avg_people_per_household,
         PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bp.n_people) AS median_occupancy
  FROM building_census bc
  GROUP BY REGIONE, PROVINCIA, bp.type
)
SELECT * FROM aggregated_stats
WHERE building_count >= {min_buildings}
ORDER BY REGIONE, PROVINCIA, type;",-- Not available in SpatiaLite,C,critical:vector,"0,c,b,bp,bc","aggregated_stats,c.PROVINCIA,bp.n_people,c.geometry,c.P1,c.REGIONE,c.SEZ2011,bp.height,c.COMUNE,bp.scenario_id,c.ST1,0.5,bp.area,bp.project_id,building_census,bc.total_households,b.building_id,b.building_geometry,bp.type,bp.building_id,bc.total_population","ST_Area,ST_Intersects,ST_Intersection"

[
  {
    "id": "A1_point_in_polygon",
    "instruction": "Convert this natural language description to spatial SQL: Find all areas that contain a specific point",
    "input": "Find all areas that contain a specific point",
    "output_postgis": "SELECT a.{id_col}, a.{attr_cols}\nFROM {areas_table} a\nJOIN {points_table} p\n  ON ST_Intersects(p.{geom}, a.{geom})\nWHERE p.{id_col} = {point_id};",
    "output_spatialite": "SELECT a.{id_col}, a.{attr_cols}\nFROM {areas_table} a\nJOIN {points_table} p\n  ON Intersects(p.{geom}, a.{geom})\nWHERE p.{id_col} = {point_id};",
    "complexity": "A",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Intersects"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A2_distance_filter",
    "instruction": "Convert this natural language description to spatial SQL: Find features within a certain distance of a point",
    "input": "Find features within a certain distance of a point",
    "output_postgis": "SELECT f.*\nFROM {features} f\nWHERE ST_DWithin(\n  f.{geom}::geography,\n  ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})::geography,\n  {meters}\n);",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nWHERE Distance(\n  f.{geom},\n  SetSRID(MakePoint({lon}, {lat}), {srid}),\n  {meters}\n);",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_MakePoint",
        "ST_DWithin",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A3_knn_nearest",
    "instruction": "Convert this natural language description to spatial SQL: Find the k nearest features to a given point",
    "input": "Find the k nearest features to a given point",
    "output_postgis": "SELECT f.*\nFROM {features} f\nORDER BY f.{geom} <-> ST_SetSRID(ST_MakePoint({lon}, {lat}), {srid})\nLIMIT {k};",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nORDER BY f.{geom} SetSRID(MakePoint({lon}, {lat}), {srid})\nLIMIT {k};",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_MakePoint",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A4_basic_buffer",
    "instruction": "Convert this natural language description to spatial SQL: Create a buffer around features",
    "input": "Create a buffer around features",
    "output_postgis": "SELECT {id_col}, ST_Buffer({geom}, {buffer_distance}) AS buffered_geom\nFROM {features};",
    "output_spatialite": "SELECT {id_col}, Buffer({geom}, {buffer_distance}) AS buffered_geom\nFROM {features};",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Buffer"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A5_area_calculation",
    "instruction": "Convert this natural language description to spatial SQL: Calculate area of polygon features",
    "input": "Calculate area of polygon features",
    "output_postgis": "SELECT {id_col}, ST_Area({geom}) AS area_sqm\nFROM {polygons}\nORDER BY area_sqm DESC;",
    "output_spatialite": "SELECT {id_col}, Area({geom}) AS area_sqm\nFROM {polygons}\nORDER BY area_sqm DESC;",
    "complexity": "A",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Area"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "A6_length_calculation",
    "instruction": "Convert this natural language description to spatial SQL: Calculate length of line features",
    "input": "Calculate length of line features",
    "output_postgis": "SELECT {id_col}, ST_Length({geom}) AS length_m\nFROM {lines}\nORDER BY length_m DESC;",
    "output_spatialite": "SELECT {id_col}, GLength({geom}) AS length_m\nFROM {lines}\nORDER BY length_m DESC;",
    "complexity": "A",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Length"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B1_spatial_join_count",
    "instruction": "Convert this natural language description to spatial SQL: Count points within each polygon area",
    "input": "Count points within each polygon area",
    "output_postgis": "SELECT a.{id_col}, COUNT(p.*) AS n_points\nFROM {areas} a\nLEFT JOIN {points} p\n  ON ST_Intersects(p.{geom}, a.{geom})\nGROUP BY a.{id_col};",
    "output_spatialite": "SELECT a.{id_col}, COUNT(p.*) AS n_points\nFROM {areas} a\nLEFT JOIN {points} p\n  ON Intersects(p.{geom}, a.{geom})\nGROUP BY a.{id_col};",
    "complexity": "B",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Intersects"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B2_reproject_buffer_join",
    "instruction": "Convert this natural language description to spatial SQL: Reproject lines, buffer them, and find intersecting sites",
    "input": "Reproject lines, buffer them, and find intersecting sites",
    "output_postgis": "WITH proj AS (\n  SELECT id, ST_Transform({geom}, {target_srid}) AS g FROM {lines}\n)\nSELECT s.*\nFROM {sites} s\nJOIN proj l\n  ON ST_DWithin(s.{geom}, ST_Buffer(l.g, {buffer_units}), 0);",
    "output_spatialite": "WITH proj AS (\n  SELECT id, Transform({geom}, {target_srid}) AS g FROM {lines}\n)\nSELECT s.*\nFROM {sites} s\nJOIN proj l\n  ON Distance(s.{geom}, Buffer(l.g, {buffer_units}), 0);",
    "complexity": "B",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "l"
      ],
      "tables": [
        "proj",
        "l.g"
      ],
      "columns": [
        "g"
      ],
      "functions": [
        "ST_Transform",
        "ST_DWithin",
        "ST_Buffer"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B3_dissolve_by_category",
    "instruction": "Convert this natural language description to spatial SQL: Merge polygons by category using union operation",
    "input": "Merge polygons by category using union operation",
    "output_postgis": "SELECT {category}, ST_Union({geom}) AS geom\nFROM {polygons}\nGROUP BY {category};",
    "output_spatialite": "SELECT {category}, ST_Union({geom}) AS geom\nFROM {polygons}\nGROUP BY {category};",
    "complexity": "B",
    "usage_index": "high:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Union"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B4_makevalid_overlay",
    "instruction": "Convert this natural language description to spatial SQL: Clean invalid geometries and calculate intersection areas",
    "input": "Clean invalid geometries and calculate intersection areas",
    "output_postgis": "WITH clean AS (\n  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}\n)\nSELECT ST_Area(ST_Intersection(c.g, o.{geom})) AS inter_area\nFROM clean c\nJOIN {other} o\n  ON ST_Intersects(c.g, o.{geom});",
    "output_spatialite": "WITH clean AS (\n  SELECT id, ST_MakeValid({geom}) AS g FROM {polygons}\n)\nSELECT Area(Intersection(c.g, o.{geom})) AS inter_area\nFROM clean c\nJOIN {other} o\n  ON Intersects(c.g, o.{geom});",
    "complexity": "B",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "c"
      ],
      "tables": [
        "c.g",
        "clean"
      ],
      "columns": [
        "g"
      ],
      "functions": [
        "ST_Area",
        "ST_MakeValid",
        "ST_Intersects",
        "ST_Intersection"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B5_spatial_aggregation",
    "instruction": "Convert this natural language description to spatial SQL: Aggregate spatial features by administrative boundary",
    "input": "Aggregate spatial features by administrative boundary",
    "output_postgis": "SELECT admin.{admin_name},\n       COUNT(f.*) AS feature_count,\n       AVG(ST_Area(f.{geom})) AS avg_area\nFROM {features} f\nJOIN {admin_boundaries} admin\n  ON ST_Within(f.{geom}, admin.{geom})\nGROUP BY admin.{admin_name};",
    "output_spatialite": "SELECT admin.{admin_name},\n       COUNT(f.*) AS feature_count,\n       AVG(Area(f.{geom})) AS avg_area\nFROM {features} f\nJOIN {admin_boundaries} admin\n  ON Within(f.{geom}, admin.{geom})\nGROUP BY admin.{admin_name};",
    "complexity": "B",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Area",
        "ST_Within"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "B6_convex_hull_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Create convex hull around grouped points",
    "input": "Create convex hull around grouped points",
    "output_postgis": "SELECT {group_col}, \n       ST_ConvexHull(ST_Collect({geom})) AS hull_geom,\n       COUNT(*) AS point_count\nFROM {points}\nGROUP BY {group_col};",
    "output_spatialite": "SELECT {group_col}, \n       ConvexHull(ST_Collect({geom})) AS hull_geom,\n       COUNT(*) AS point_count\nFROM {points}\nGROUP BY {group_col};",
    "complexity": "B",
    "usage_index": "medium:vector",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Collect",
        "ST_ConvexHull"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C10_grid_building_proximity",
    "instruction": "Convert this natural language description to spatial SQL: Analyze electrical grid infrastructure proximity to buildings with voltage level considerations",
    "input": "Analyze electrical grid infrastructure proximity to buildings with voltage level considerations",
    "output_postgis": "WITH building_grid_proximity AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area,\n         gb.bus_id, gb.voltage_kv, gb.name as substation_name,\n         ST_Distance(b.building_geometry, gb.geometry) AS distance_to_grid,\n         RANK() OVER (PARTITION BY b.building_id ORDER BY ST_Distance(b.building_geometry, gb.geometry)) AS proximity_rank\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id  \n  JOIN {grid_bus} gb ON gb.project_id = bp.project_id AND gb.scenario_id = bp.scenario_id\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n    AND gb.in_service = true\n    AND ST_DWithin(b.building_geometry, gb.geometry, {max_distance})\n),\nvoltage_requirements AS (\n  SELECT building_id, type, height, area,\n         CASE \n           WHEN type IN ('industrial', 'commercial') AND area > 1000 THEN 'high_voltage'\n           WHEN type = 'residential' AND height > 20 THEN 'medium_voltage'\n           ELSE 'low_voltage'\n         END AS required_voltage_level\n  FROM building_grid_proximity\n  WHERE proximity_rank = 1\n)\nSELECT bgp.building_id, bgp.type, bgp.distance_to_grid,\n       bgp.voltage_kv, bgp.substation_name,\n       vr.required_voltage_level,\n       CASE \n         WHEN vr.required_voltage_level = 'high_voltage' AND bgp.voltage_kv >= 10 THEN 'adequate'\n         WHEN vr.required_voltage_level = 'medium_voltage' AND bgp.voltage_kv >= 1 THEN 'adequate'\n         WHEN vr.required_voltage_level = 'low_voltage' AND bgp.voltage_kv >= 0.4 THEN 'adequate'\n         ELSE 'insufficient'\n       END AS grid_adequacy\nFROM building_grid_proximity bgp\nJOIN voltage_requirements vr ON bgp.building_id = vr.building_id\nWHERE bgp.proximity_rank = 1\nORDER BY bgp.distance_to_grid;",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "0",
        "bgp",
        "vr",
        "gb",
        "b",
        "bp"
      ],
      "tables": [
        "bgp.distance_to_grid",
        "gb.name",
        "bgp.substation_name",
        "vr.required_voltage_level",
        "gb.geometry",
        "bgp.proximity_rank",
        "gb.bus_id",
        "bgp.type",
        "building_grid_proximity",
        "gb.project_id",
        "gb.in_service",
        "bp.height",
        "bp.scenario_id",
        "bgp.building_id",
        "bp.area",
        "voltage_requirements",
        "bp.project_id",
        "0.4",
        "b.building_id",
        "b.building_geometry",
        "gb.scenario_id",
        "bp.type",
        "bp.building_id",
        "vr.building_id",
        "bgp.voltage_kv",
        "gb.voltage_kv"
      ],
      "columns": [
        "required_voltage_level",
        "area",
        "type",
        "substation_name",
        "building_geometry",
        "bus_id",
        "in_service",
        "height",
        "geometry",
        "distance_to_grid",
        "voltage_kv",
        "proximity_rank",
        "name",
        "4"
      ],
      "functions": [
        "ST_DWithin",
        "ST_Distance"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C11_multi_schema_spatial_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Comprehensive spatial analysis across vector, census, and building data with distance-based clustering",
    "input": "Comprehensive spatial analysis across vector, census, and building data with distance-based clustering",
    "output_postgis": "WITH spatial_clusters AS (\n  SELECT b.building_id, bp.type, bp.n_people,\n         c.SEZ2011, c.P1 as population, c.REGIONE,\n         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) \n         OVER (PARTITION BY bp.type) AS cluster_id\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON ST_Within(ST_Centroid(b.building_geometry), c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n),\ncluster_stats AS (\n  SELECT cluster_id, type, REGIONE,\n         COUNT(*) AS building_count,\n         SUM(n_people) AS total_residents,\n         AVG(population) AS avg_census_population,\n         ST_ConvexHull(ST_Collect(ST_Centroid(b.building_geometry))) AS cluster_boundary\n  FROM spatial_clusters sc\n  JOIN {buildings} b ON sc.building_id = b.building_id\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, type, REGIONE\n  HAVING COUNT(*) >= {min_cluster_size}\n)\nSELECT cluster_id, type, REGIONE, building_count, total_residents,\n       ROUND(avg_census_population, 0) AS avg_census_pop,\n       ST_Area(cluster_boundary) AS cluster_area_sqm,\n       ROUND(total_residents::float / (ST_Area(cluster_boundary) / 10000), 2) AS density_per_hectare\nFROM cluster_stats\nORDER BY density_per_hectare DESC;",
    "output_spatialite": "WITH spatial_clusters AS (\n  SELECT b.building_id, bp.type, bp.n_people,\n         c.SEZ2011, c.P1 as population, c.REGIONE,\n         ST_ClusterDBSCAN(b.building_geometry, eps := {cluster_distance}, minpoints := {min_points}) \n         OVER (PARTITION BY bp.type) AS cluster_id\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON Within(Centroid(b.building_geometry), c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n),\ncluster_stats AS (\n  SELECT cluster_id, type, REGIONE,\n         COUNT(*) AS building_count,\n         SUM(n_people) AS total_residents,\n         AVG(population) AS avg_census_population,\n         ConvexHull(ST_Collect(Centroid(b.building_geometry))) AS cluster_boundary\n  FROM spatial_clusters sc\n  JOIN {buildings} b ON sc.building_id = b.building_id\n  WHERE cluster_id IS NOT NULL\n  GROUP BY cluster_id, type, REGIONE\n  HAVING COUNT(*) >= {min_cluster_size}\n)\nSELECT cluster_id, type, REGIONE, building_count, total_residents,\n       ROUND(avg_census_population, 0) AS avg_census_pop,\n       Area(cluster_boundary) AS cluster_area_sqm,\n       ROUND(total_residents::float / (Area(cluster_boundary) / 10000), 2) AS density_per_hectare\nFROM cluster_stats\nORDER BY density_per_hectare DESC;",
    "complexity": "C",
    "usage_index": "critical:clustering",
    "evidence": {
      "database": "general",
      "schemas": [
        "c",
        "b",
        "bp",
        "sc"
      ],
      "tables": [
        "bp.scenario_id",
        "cluster_stats",
        "b.building_id",
        "b.building_geometry",
        "sc.building_id",
        "c.REGIONE",
        "spatial_clusters",
        "c.SEZ2011",
        "bp.type",
        "bp.project_id",
        "bp.n_people",
        "bp.building_id",
        "c.geometry",
        "c.P1"
      ],
      "columns": [
        "SEZ2011",
        "type",
        "n_people",
        "building_geometry",
        "geometry",
        "P1",
        "REGIONE"
      ],
      "functions": [
        "ST_Collect",
        "ST_Area",
        "ST_ConvexHull",
        "ST_Within",
        "ST_Centroid",
        "ST_ClusterDBSCAN"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C1_knn_per_group",
    "instruction": "Convert this natural language description to spatial SQL: Find k nearest neighbors for each point in a group",
    "input": "Find k nearest neighbors for each point in a group",
    "output_postgis": "SELECT *\nFROM (\n  SELECT p.id AS p_id, f.id AS f_id,\n         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} <-> p.{geom}) AS rk\n  FROM {points} p\n  JOIN {features} f ON TRUE\n) x\nWHERE rk <= {k};",
    "output_spatialite": "SELECT *\nFROM (\n  SELECT p.id AS p_id, f.id AS f_id,\n         ROW_NUMBER() OVER (PARTITION BY p.id ORDER BY f.{geom} p.{geom}) AS rk\n  FROM {points} p\n  JOIN {features} f ON TRUE\n) x\nWHERE rk <= {k};",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "f",
        "p"
      ],
      "tables": [
        "p.id",
        "f.id"
      ],
      "columns": [
        "id"
      ],
      "functions": [],
      "template_source": "general"
    }
  },
  {
    "id": "C2_linear_referencing",
    "instruction": "Convert this natural language description to spatial SQL: Project point onto line and split line at that location",
    "input": "Project point onto line and split line at that location",
    "output_postgis": "WITH s AS (\n  SELECT l.id, ST_LineLocatePoint(l.{geom}, ST_SetSRID(ST_MakePoint({lon},{lat}),{srid})) AS frac\n  FROM {lines} l WHERE l.id = {line_id}\n)\nSELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,\n       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end\nFROM {lines} l\nJOIN s ON s.id = l.id;",
    "output_spatialite": "WITH s AS (\n  SELECT l.id, ST_LineLocatePoint(l.{geom}, SetSRID(MakePoint({lon},{lat}),{srid})) AS frac\n  FROM {lines} l WHERE l.id = {line_id}\n)\nSELECT ST_LineSubstring(l.{geom}, 0, s.frac) AS from_start,\n       ST_LineSubstring(l.{geom}, s.frac, 1) AS to_end\nFROM {lines} l\nJOIN s ON s.id = l.id;",
    "complexity": "C",
    "usage_index": "very_high:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "l",
        "s"
      ],
      "tables": [
        "l.id",
        "s.id",
        "s.frac"
      ],
      "columns": [
        "frac",
        "id"
      ],
      "functions": [
        "ST_LineLocatePoint",
        "ST_MakePoint",
        "ST_LineSubstring",
        "ST_SetSRID"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C3_cluster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Perform DBSCAN clustering on point locations",
    "input": "Perform DBSCAN clustering on point locations",
    "output_postgis": "SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *\nFROM {points};",
    "output_spatialite": "SELECT (ST_ClusterDBSCAN({geom}, eps := {eps}, minpoints := {minpts})) OVER () AS cluster_id, *\nFROM {points};",
    "complexity": "C",
    "usage_index": "low:clustering",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_ClusterDBSCAN"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C4_topology_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Analyze topological relationships between polygon features",
    "input": "Analyze topological relationships between polygon features",
    "output_postgis": "SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,\n       CASE \n         WHEN ST_Contains(a.{geom}, b.{geom}) THEN 'contains'\n         WHEN ST_Within(a.{geom}, b.{geom}) THEN 'within'\n         WHEN ST_Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'\n         WHEN ST_Touches(a.{geom}, b.{geom}) THEN 'touches'\n         ELSE 'disjoint'\n       END AS relationship\nFROM {polygons} a\nJOIN {polygons} b ON a.{id_col} != b.{id_col}\nWHERE ST_Intersects(a.{geom}, b.{geom}) OR ST_Touches(a.{geom}, b.{geom});",
    "output_spatialite": "SELECT a.{id_col} AS poly_a, b.{id_col} AS poly_b,\n       CASE \n         WHEN Contains(a.{geom}, b.{geom}) THEN 'contains'\n         WHEN Within(a.{geom}, b.{geom}) THEN 'within'\n         WHEN Overlaps(a.{geom}, b.{geom}) THEN 'overlaps'\n         WHEN Touches(a.{geom}, b.{geom}) THEN 'touches'\n         ELSE 'disjoint'\n       END AS relationship\nFROM {polygons} a\nJOIN {polygons} b ON a.{id_col} != b.{id_col}\nWHERE Intersects(a.{geom}, b.{geom}) OR Touches(a.{geom}, b.{geom});",
    "complexity": "C",
    "usage_index": "critical:topology",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_Overlaps",
        "ST_Intersects",
        "ST_Within",
        "ST_Contains",
        "ST_Touches"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C5_network_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Find connected components in a line network",
    "input": "Find connected components in a line network",
    "output_postgis": "WITH nodes AS (\n  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom\n  FROM {lines}\n),\nconnected AS (\n  SELECT ST_ClusterIntersecting(node_geom) AS component\n  FROM nodes\n)\nSELECT ROW_NUMBER() OVER () AS component_id, \n       ST_NumGeometries(component) AS node_count\nFROM connected;",
    "output_spatialite": "WITH nodes AS (\n  SELECT DISTINCT unnest(ARRAY[ST_StartPoint({geom}), ST_EndPoint({geom})]) AS node_geom\n  FROM {lines}\n),\nconnected AS (\n  SELECT ST_ClusterIntersecting(node_geom) AS component\n  FROM nodes\n)\nSELECT ROW_NUMBER() OVER () AS component_id, \n       ST_NumGeometries(component) AS node_count\nFROM connected;",
    "complexity": "C",
    "usage_index": "medium:network",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [
        "connected",
        "nodes"
      ],
      "columns": [],
      "functions": [
        "ST_ClusterIntersecting",
        "ST_NumGeometries",
        "ST_StartPoint",
        "ST_EndPoint"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C6_raster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Extract raster values at point locations",
    "input": "Extract raster values at point locations",
    "output_postgis": "SELECT p.id, ST_Value(r.rast, 1, p.{geom}) AS elevation\nFROM {raster_table} r\nJOIN {points} p\n  ON ST_Intersects(r.rast, p.{geom});",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "critical:raster",
    "evidence": {
      "database": "general",
      "schemas": [
        "p",
        "r"
      ],
      "tables": [
        "p.id",
        "r.rast"
      ],
      "columns": [
        "rast",
        "id"
      ],
      "functions": [
        "ST_Value",
        "ST_Intersects"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C6_spatial_index_query",
    "instruction": "Convert this natural language description to spatial SQL: Efficient spatial query using spatial index",
    "input": "Efficient spatial query using spatial index",
    "output_postgis": "-- Not available in PostGIS",
    "output_spatialite": "SELECT f.*\nFROM {features} f\nWHERE f.ROWID IN (\n  SELECT ROWID FROM SpatialIndex \n  WHERE f_table_name = '{features}' \n  AND search_frame = BuildMbr({xmin}, {ymin}, {xmax}, {ymax}, {srid})\n);",
    "complexity": "C",
    "usage_index": "low:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "f"
      ],
      "tables": [
        "f.ROWID",
        "SpatialIndex"
      ],
      "columns": [
        "ROWID"
      ],
      "functions": [],
      "template_source": "general"
    }
  },
  {
    "id": "C7_3d_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Calculate 3D distances between points with elevation",
    "input": "Calculate 3D distances between points with elevation",
    "output_postgis": "SELECT a.{id_col}, b.{id_col},\n       ST_3DDistance(a.{geom}, b.{geom}) AS distance_3d\nFROM {points_3d} a\nJOIN {points_3d} b ON a.{id_col} != b.{id_col}\nWHERE ST_3DDistance(a.{geom}, b.{geom}) < {max_distance};",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "low:3d",
    "evidence": {
      "database": "general",
      "schemas": [],
      "tables": [],
      "columns": [],
      "functions": [
        "ST_3DDistance"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C8_building_height_raster_analysis",
    "instruction": "Convert this natural language description to spatial SQL: Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference",
    "input": "Calculate building heights by clipping DSM and DTM rasters with building geometries and computing the average difference",
    "output_postgis": "WITH building_dsm AS (\n  SELECT b.building_id, b.building_geometry,\n         AVG(ST_Value(dsm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dsm.rast)))) AS avg_dsm_height\n  FROM {buildings} b\n  JOIN {dsm_raster} dsm ON ST_Intersects(b.building_geometry, dsm.rast)\n  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'\n  GROUP BY b.building_id, b.building_geometry\n),\nbuilding_dtm AS (\n  SELECT b.building_id,\n         AVG(ST_Value(dtm.rast, 1, ST_Centroid(ST_Intersection(b.building_geometry, dtm.rast)))) AS avg_dtm_height\n  FROM {buildings} b\n  JOIN {dtm_raster} dtm ON ST_Intersects(b.building_geometry, dtm.rast)\n  WHERE b.project_id = '{project_id}' AND b.scenario_id = '{scenario_id}'\n  GROUP BY b.building_id\n)\nSELECT dsm.building_id, dsm.building_geometry,\n       dsm.avg_dsm_height, dtm.avg_dtm_height,\n       ROUND((dsm.avg_dsm_height - dtm.avg_dtm_height), 2) AS calculated_height,\n       ST_Area(dsm.building_geometry) AS building_area\nFROM building_dsm dsm\nJOIN building_dtm dtm ON dsm.building_id = dtm.building_id\nWHERE (dsm.avg_dsm_height - dtm.avg_dtm_height) > {min_height};",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "critical:raster",
    "evidence": {
      "database": "general",
      "schemas": [
        "dsm",
        "dtm",
        "b"
      ],
      "tables": [
        "b.scenario_id",
        "b.building_id",
        "b.building_geometry",
        "dsm.avg_dsm_height",
        "dtm.building_id",
        "building_dtm",
        "dsm.building_geometry",
        "dsm.rast",
        "dtm.rast",
        "dsm.building_id",
        "dtm.avg_dtm_height",
        "building_dsm",
        "b.project_id"
      ],
      "columns": [
        "avg_dtm_height",
        "avg_dsm_height",
        "rast",
        "building_geometry"
      ],
      "functions": [
        "ST_Area",
        "ST_Intersects",
        "ST_Centroid",
        "ST_Value",
        "ST_Intersection"
      ],
      "template_source": "general"
    }
  },
  {
    "id": "C9_census_building_correlation",
    "instruction": "Convert this natural language description to spatial SQL: Correlate building properties with census data by spatial overlay analysis",
    "input": "Correlate building properties with census data by spatial overlay analysis",
    "output_postgis": "WITH building_census AS (\n  SELECT b.building_id, bp.type, bp.height, bp.area, bp.n_people,\n         c.SEZ2011, c.P1 as total_population, c.ST1 as total_households,\n         c.REGIONE, c.PROVINCIA, c.COMUNE,\n         ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) AS overlap_ratio\n  FROM {buildings} b\n  JOIN {building_properties} bp ON b.building_id = bp.building_id\n  JOIN {census_geo} c ON ST_Intersects(b.building_geometry, c.geometry)\n  WHERE bp.project_id = '{project_id}' AND bp.scenario_id = '{scenario_id}'\n    AND ST_Area(ST_Intersection(b.building_geometry, c.geometry)) / ST_Area(b.building_geometry) > 0.5\n),\naggregated_stats AS (\n  SELECT REGIONE, PROVINCIA, bp.type,\n         COUNT(*) AS building_count,\n         AVG(bp.height) AS avg_building_height,\n         SUM(bp.area) AS total_building_area,\n         AVG(bc.total_population::float / NULLIF(bc.total_households, 0)) AS avg_people_per_household,\n         PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY bp.n_people) AS median_occupancy\n  FROM building_census bc\n  GROUP BY REGIONE, PROVINCIA, bp.type\n)\nSELECT * FROM aggregated_stats\nWHERE building_count >= {min_buildings}\nORDER BY REGIONE, PROVINCIA, type;",
    "output_spatialite": "-- Not available in SpatiaLite",
    "complexity": "C",
    "usage_index": "critical:vector",
    "evidence": {
      "database": "general",
      "schemas": [
        "0",
        "c",
        "b",
        "bp",
        "bc"
      ],
      "tables": [
        "aggregated_stats",
        "c.PROVINCIA",
        "bp.n_people",
        "c.geometry",
        "c.P1",
        "c.REGIONE",
        "c.SEZ2011",
        "bp.height",
        "c.COMUNE",
        "bp.scenario_id",
        "c.ST1",
        "0.5",
        "bp.area",
        "bp.project_id",
        "building_census",
        "bc.total_households",
        "b.building_id",
        "b.building_geometry",
        "bp.type",
        "bp.building_id",
        "bc.total_population"
      ],
      "columns": [
        "area",
        "total_population",
        "SEZ2011",
        "type",
        "PROVINCIA",
        "n_people",
        "building_geometry",
        "height",
        "geometry",
        "COMUNE",
        "P1",
        "5",
        "ST1",
        "total_households",
        "REGIONE"
      ],
      "functions": [
        "ST_Area",
        "ST_Intersects",
        "ST_Intersection"
      ],
      "template_source": "general"
    }
  }
]